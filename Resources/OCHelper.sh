#!/bin/bash -e
#
# OC Helper
# Copyright (c) 2019 - LogRhythm - Tony MASSÃ‰ (tony.masse@logrhythm.com)
#
# Skeleton initially based on shell-script-skeleton v0.0.3 <http://github.com/z017/shell-script-skeleton>

#######################################
# SCRIPT CONSTANTS & VARIABLES
#######################################

# Script version
readonly VERSION=1.0.143

# List of required tools, example: REQUIRED_TOOLS=(git ssh)
readonly REQUIRED_TOOLS=()

# Long Options. To expect an argument for an option, just place a : (colon)
# after the proper option flag.
# Generated by "20190731.Open Collector UI - OCHelper - Specs.xlsx", Tab "Long Params"
readonly LONG_OPTS=(help version force \
                    CheckOCHelperVersion \
                    CheckOSVersion \
                    CheckDockerPresence \
                    CheckDockerVersion \
                    CheckOCPresence \
                    CheckOCVersion \
                    CheckOCHealth \
                    ReadOCConfiguration \
                    ListInstalledPipelines \
                    ListPipelineProjects \
                    GetPipelineProjectFilter: \
                    GetPipelineProjectTransform: \
                    InstallDocker: \
                    UpgradeDocker: \
                    DeployLatestLrctl: \
                    DeployLatestLRJQ: \
                    DeployLatestOcpipeline: \
                    InstallOC: \
                    UpgradeOC: \
                    RestartOC: \
                    StartOC: \
                    StopOC: \
                    WriteOCConfiguration: \
                    CreatePipelineProject: \
                    UpdatePipelineProjectFilter: \
                    UpdatePipelineProjectTransform: \
                    PackagePipelineProject: \
                    InstallPipelinePackage: \
                    TestPipelineProjectFilter: \
                    TestPipelineProjectTransform: \
                    DeletePipelineProject: \
                    CheckInternetConnectivity \
                    SelfIntegrityCheck \
                    ReadOCLogs \
                    EnableInstalledPipeline: \
                    DisableInstalledPipeline: \
                     \
                     \
                   )

# Short Options. To expect an argument for an option, just place a : (colon)
# after the proper option flag.
readonly SHORT_OPTS=hv

# Script name
readonly SCRIPT_NAME=${0##*/}

# Force flag
declare FORCE=false

readonly PROJECT_ROOT=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)

readonly PIPELINE_PROJECT_ROOT="$PROJECT_ROOT/PipelineProjects"
# Delimiters to sqeeze commas inbetween (this is used to split JSON array)
readonly BACK_TO_BACK_BRACKETS="}{"
readonly BACK_TO_BACK_BRACKETS_WITH_COMMA="},{"
# Domains with a required connectivity to. As they are used for download and upgrades
readonly REQUIRED_DOMAINS=("google.com" "download.docker.com" "github.com" "gcr.io" "logrhythm.box.com")
readonly REQUIRED_DOMAINS_FOR_AZURE=("windows.net")


#######################################
# FUNCTIONS
#######################################

# Print out messages to STDERR.
function ech() { echo -e "$@" >&2; }

# Print out error messages to STDERR.
function err() { echo -e "\033[0;31mERROR: $@\033[0m" >&2;  }

# Shows an error if required tools are not installed.
function required {
  local e=0
  for tool in "$@"; do
    type $tool >/dev/null 2>&1 || {
      e=1 && err "$tool is required for running this script. Please install $tool and try again."
    }
  done
  [[ $e < 1 ]] || exit 2
}

# Parse template file variables in the format "{{ VAR }}" with the "VAR" value.
# parse_template <input file template> <output file> <string of variables>
function parse_template {
  local e=0
  [[ ! -f "$1" ]] && err "$1 is not a valid file." && e=1
  [[ $2 != ${2%/*} ]] && mkdir -p ${2%/*}
  [[ -z $3 ]] && err "$3, must be an string of variables to replace" && e=1
  if [[ $e > 0 ]]; then
    ech "Usage: parse_template <input file template> <output file> <string of variables>"
    exit 2
  fi
  local args
  for v in $3; do
    args="${args}s~{{ $v }}~${!v}~g;"
  done
  sed "$args" < $1 > $2
}

# Parse all template files ".tpl" in the input_dir and saved them to output_dir
# parse_templates <input_dir> <output_dir> <string of variables>
function parse_templates {
  local e=0
  [[ ! -d $1 ]] && err "$1 is not a valid directory." && e=1
  [[ -z $3 ]] && err "$3, must be an string of variables to replace" && e=1
  if [[ $e > 0 ]]; then
    ech "Usage: parse_templates <input_dir> <output_dir> <string of variables>"
    exit 2
  fi
  # parse each file
  for file in "$1"/*.tpl*; do
    local filename=${file##*/}
    local outfile=${filename%.tpl*}${filename##*.tpl}
    parse_template $file $2/$outfile "$3"
  done
}




#######################################
# help command
#######################################
# Generated by "20190731.Open Collector UI - OCHelper - Specs.xlsx", Tab "Help"

function help_command() {
  cat <<END;

USAGE:
  $SCRIPT_NAME [option [input data]]

OPTIONS:
  --help, -h                          Display detailed help.
  --version, -v                       Print version information.
  --force                             Don't ask for confirmation.
  --                                  Denotes the end of the options.  Arguments after this
                                      will be handled as parameters even if they start with
                                      a '-'.
  --CheckOCHelperVersion              Returns the version of the OC Helper script.
  --CheckOSVersion                    Returns the version of the OS.
  --CheckDockerPresence               Check Docker presence.
  --CheckDockerVersion                Returns the version of Docker.
  --CheckOCPresence                   Check OC presence.
  --CheckOCVersion                    Returns the version of the Open Collector.
  --CheckOCHealth                     Check OC health.
  --ReadOCConfiguration               Extract OC Configuration.
  --ListInstalledPipelines            List Installed Pipelines.
  --ListPipelineProjects              List Pipeline Projects.
  --GetPipelineProjectFilter          Get Pipeline Project Filter. Input format: {"ProjectName": "%s"}
  --GetPipelineProjectTransform       Get Pipeline Project Transform. Input format: {"ProjectName": "%s"}
  --InstallDocker                     Install Docker. Input format: {"ExtraParameters": "%s_base64_encoded"}
  --UpgradeDocker                     Upgrade Docker. Input format: {"ExtraParameters": "%s_base64_encoded"}
  --DeployLatestLrctl                 Deploy Latest lrctl. Input format: {"ExtraRepositories": [{"URL":"%s"}]}
  --DeployLatestLRJQ                  Deploy Latest lrjq. Input format: {"ExtraRepositories": [{"URL":"%s"}]}
  --DeployLatestOcpipeline            Deploy Latest ocpipeline. Input format: {"ExtraRepositories": [{"URL":"%s"}]}
  --InstallOC                         Install OC. Input format: {"ExtraParameters": "%s_base64_encoded"}
  --UpgradeOC                         Upgrade OC. Input format: {"ExtraParameters": "%s_base64_encoded"}
  --RestartOC                         Restart OC. Input format: {"ExtraParameters": "%s_base64_encoded"}
  --StartOC                           Start OC. Input format: {"ExtraParameters": "%s_base64_encoded"}
  --StopOC                            Stop OC. Input format: {"ExtraParameters": "%s_base64_encoded"}
  --WriteOCConfiguration              Write OC Configuration. Input format: {"RawConfig": "%s_base64_encoded"}
  --CreatePipelineProject             Create new Pipeline project. Input format: {"ProjectName": "%s"}
  --UpdatePipelineProjectFilter       Update Pipeline Project Filter. Input format: {"ProjectName": "%s", "NewFilter": "%s_base64_encoded"}
  --UpdatePipelineProjectTransform    Update Pipeline Project Transform. Input format: {"ProjectName": "%s", "NewTransform": "%s_base64_encoded"}
  --PackagePipelineProject            Package Pipeline Project. Input format: {"ProjectName": "%s"}
  --InstallPipelinePackage            Install Pipeline Package. Input format: {"ProjectName": "%s"}
  --TestPipelineProjectFilter         Test Pipeline Project Filter. Input format: {"ProjectName": "%s", "LogToTest": "%s_base64_encoded"}
  --TestPipelineProjectTransform      Test Pipeline Project Transform. Input format: {"ProjectName": "%s", "LogToTest": "%s_base64_encoded"}
  --DeletePipelineProject             Delete Pipeline project. Input format: {"ProjectName": "%s"}
  --CheckInternetConnectivity         Check for Internet Connectivity.
  --SelfIntegrityCheck                Self integrity check.
  --ReadOCLogs                        Extract OC Logs.
  --EnableInstalledPipeline           Enable Installed Pipeline. Input format: {"PipelineName": "%s"}
  --DisableInstalledPipeline          Disable Installed Pipeline. Input format: {"PipelineName": "%s"}

EXAMPLES:
  $SCRIPT_NAME --CheckOCPresence 

  $SCRIPT_NAME --CreatePipelineProject '{"ProjectName": "MyCustomBeat"}'

  $SCRIPT_NAME --UpdatePipelineProjectFilter '{"ProjectName": "MyCustomBeat", "NewFilter": "IyBDaGVjayBpZiBKU09OIG1hdGNoZXMgdGhlIEF6dXJlQmVhdC4KZGVmIGlzX0NvbnRvc29XZWJBcHA6CiAgLiJAbWV0YWRhdGEiLmJlYXQgPT0gIkF6dXJlQmVhdCIKOw=="}'

  $SCRIPT_NAME --UpdatePipelineProjectTransform '{"ProjectName": "MyCustomBeat", "NewTransform": "ZGVmIHRyYW5zZm9ybToKICAub3V0cHV0LmJlYXRuYW1lCT0gIC4iQG1ldGFkYXRhIi50b3BpYwkJfAogIC5vdXRwdXQubG9naW4gCT0gIC5yZXF1ZXN0LmFjdG9yLmVtYWlsCQl8CiAgLm91dHB1dC5zaXAgCSAJPSAgLnJlcXVlc3QuYWN0b3IuaXAJCXwKICAub3V0cHV0LmFjdGlvbgk9ICAucmVxdWVzdC5tZXRob2QJCXwKICAub3V0cHV0LnJlc3BvbnNjb2RlIAk9ICAucmVxdWVzdC5yZXNwb25zZUNvZGUJfAogIC5vdXRwdXQua2lsb2J5dGVzb3V0CT0gIC5yZXF1ZXN0LnJlc3BvbnNlU2l6ZSAvIDEwMDAJfAogIC5vdXRwdXQub2JqZWN0IAk9ICAucmVxdWVzdC5lbmRwb2ludCAJCXwKICAub3V0cHV0Lm9iamVjdG5hbWUgICAgPSAgKC5yZXF1ZXN0LmVuZHBvaW50IHwgc3BsaXQoIi8iKSB8IC5bMV0/KSB8CiAgLm91dHB1dC5vYmplY3R0eXBlICAgID0gICgucmVxdWVzdC5oZWFkZXJzIHwgLltdPyB8IHNlbGVjdCgubmFtZT8gPT0gImNvbnRlbnRUeXBlIikgfCAudmFsdWU/KSB8CiAgLm91dHB1dAo7"}'

  $SCRIPT_NAME --PackagePipelineProject '{"ProjectName": "MyCustomBeat"}'

  $SCRIPT_NAME --InstallPipelinePackage '{"ProjectName": "MyCustomBeat"}'

END
  exit 1
}

#######################################
# version command
#######################################
function version_command() {
  echo "$SCRIPT_NAME version $VERSION"
}

#######################################
# default command
#######################################
function default_command() {
  # set default command here
  help_command
}

#######################################
# CheckOCHelperVersion
#
# Goal: Returns the version of this script.
# Input: 
# Output: {"Version":{"Detailed":{"Major":"%d", "Minor":"%d", "Build":"%d"}, "Full":"%s"}}
#######################################
function CheckOCHelperVersion() {
  echo -e $VERSION | awk -F. -v OFS= '{print "{\"Version\":{\"Detailed\":{\"Major\":\""$1,"\", \"Minor\":\""$2,"\", \"Build\":\""$3,"\"}, \"Full\":\""$1,"."$2,"."$3,"\"}}"}'
  exit 0
}

#######################################
# CheckOSVersion
#
# Goal: Returns the version of the OS.
# Input: 
# Output: {"Version":{"Detailed":{"Major":"%d", "Minor":"%d", "Build":"%d"}, "Full":"%s"}}
#######################################
function CheckOSVersion() {
  uname -r | awk -F. -v OFS= '{print "{\"Version\":{\"Detailed\":{\"Major\":\""$1,"\", \"Minor\":\""$2,"\", \"Build\":\""$3,"\"}, \"Full\":\""$1,"."$2,"."$3,"\"}}"}'
  exit 0
}

#######################################
# CheckDockerPresence
#
# Goal: Check Docker presence.
# Input: 
# Output: {"Presence": "%s"}
#######################################
function CheckDockerPresence() {
  local result=1
  docker -v >/dev/null 2>/dev/null || result=0

  if [ $result -eq 1 ]; then
    echo -e "{\"Presence\": \"true\"}"
    exit 0
  else
    echo -e "{\"Presence\": \"false\"}"
    exit 1
  fi
  exit 1
}

#######################################
# CheckDockerVersion
#
# Goal: Returns the version of Docker.
# Input: 
# Output: {"Version":{"Detailed":{"Major":"%d", "Minor":"%d", "Build":"%d"}, "Full":"%s"}}
#######################################
function CheckDockerVersion() {
  local Result=1
  local docker_version=""
  docker_version=$(docker -v 2>/dev/null) || docker_version=""
  #docker_version="Docker version 1.7.0, build 0baf609"

  local regex=".*?(([0-9]+)\.([0-9]+)\.([0-9]+))"
  if [[ $docker_version =~ $regex ]]
  then
    echo -e "{\"Version\":{\"Detailed\":{\"Major\":\"${BASH_REMATCH[2]}\", \"Minor\":\"${BASH_REMATCH[3]}\", \"Build\":\"${BASH_REMATCH[4]}\"}, \"Full\":\"${BASH_REMATCH[1]}\"}}"
  exit 0
  else
    echo -e "{\"Version\":{\"Detailed\":{\"Major\":\"-1\", \"Minor\":\"0\", \"Build\":\"0\"}, \"Full\":\"-1\"}}"
    exit 1
  fi

  exit 1
}

#######################################
# CheckOCPresence
#
# Goal: Check OC presence.
# Input: 
# Output: {"Presence": "%s"}
#######################################
function CheckOCPresence() {
  local oc_present=0
  
  # First establish if "lrctl" is present and running
  local lrctl_present=1
  ./lrctl --help >/dev/null 2>/dev/null || lrctl_present=-1

  if [ $lrctl_present -eq 1 ]; then
    # "lrctl"is present. Now check if the OC is installed too.
    oc_present=$(./lrctl status | grep -c -i open_collector 2>/dev/null) || oc_present=-1
  else
    # No "lrctl", we stop here and claim OC is not present.
    oc_present=0
  fi

  # Output the result
  if [ $oc_present -ge 1 ]; then
    echo -e "{\"Presence\": \"true\"}"
    exit 0
  else
    echo -e "{\"Presence\": \"false\"}"
    exit 1
  fi

  exit 1
}

#######################################
# CheckOCVersion
#
# Goal: Returns the version of the Open Collector.
# Input: 
# Output: {"Version":{"Detailed":{"Major":"%d", "Minor":"%d", "Build":"%d"}, "Full":"%s"}}
#######################################
function CheckOCVersion() {
  local oc_version=""
  
  # First establish if "lrctl" is present and running
  local lrctl_present=1
  ./lrctl --help >/dev/null 2>/dev/null || lrctl_present=-1

  if [ $lrctl_present -eq 1 ]; then
    # "lrctl"is present.
    oc_version=$(./lrctl status 2>/dev/null | grep -i open_collector 2>/dev/null) || oc_version=""
  #oc_version="open_collector   0.1.10     2019-07-12 09:46:01 +0000 UTC   Restarting (1) 44 seconds ago"

    local regex="open_collector *(([0-9]+)\.([0-9]+)\.([0-9]+))"
    if [[ $oc_version =~ $regex ]]
    then
      echo -e "{\"Version\":{\"Detailed\":{\"Major\":\"${BASH_REMATCH[2]}\", \"Minor\":\"${BASH_REMATCH[3]}\", \"Build\":\"${BASH_REMATCH[4]}\"}, \"Full\":\"${BASH_REMATCH[1]}\"}}"
    exit 0
    else
      echo -e "{\"Version\":{\"Detailed\":{\"Major\":\"-1\", \"Minor\":\"0\", \"Build\":\"0\"}, \"Full\":\"-1\"}}"
      exit 1
    fi

  else
    # No "lrctl", we stop here and claim OC is not present.
    echo -e "{\"Version\":{\"Detailed\":{\"Major\":\"-1\", \"Minor\":\"0\", \"Build\":\"0\"}, \"Full\":\"-1\"}}"
    exit 1
  fi
  
  exit 1
}

#######################################
# CheckOCHealth
#
# Goal: Check OC health.
# Input: 
# Output: {"Health": "%s"}
#######################################
function CheckOCHealth() {
  local oc_status=""
  
  # First establish if "lrctl" is present and running
  local lrctl_present=1
  ./lrctl --help >/dev/null 2>/dev/null || lrctl_present=-1

  if [ $lrctl_present -eq 1 ]; then
    # "lrctl"is present.
    oc_status=$(./lrctl status 2>/dev/null | grep -i open_collector 2>/dev/null) || OC_VERSION=""
  #oc_status="open_collector   0.1.10     2019-07-12 09:46:01 +0000 UTC   Restarting (1) 44 seconds ago"

    local regex="open_collector *[0-9]+\.[0-9]+\.[0-9]+ *[0-9]+-[0-9]+-[0-9]+ +[0-9]+:[0-9]+:[0-9]+ +\+[0-9]+ +UTC +(\w*)"
    if [[ $oc_status =~ $regex ]]
    then
      echo -e "{\"Health\":\"${BASH_REMATCH[1]}\"}"
    exit 0
    else
      echo -e "{\"Health\":\"\"}"
      exit 1
    fi

  else
    # No "lrctl", we stop here.
      echo -e "{\"Health\":\"\"}"
    exit 1
  fi
  
  exit 1
}

#######################################
# ReadOCConfiguration
#
# Goal: Extract OC Configuration.
# Input: 
# Output: %RawConfig%
#######################################
function ReadOCConfiguration() {
  # First establish if "lrctl" is present and running
  local lrctl_present=1
  ./lrctl --help >/dev/null 2>/dev/null || lrctl_present=-1

  if [ $lrctl_present -eq 1 ]; then
    # "lrctl"is present.
    ./lrctl open-collector config export 2>/dev/null
    exit 0
  else
    # No "lrctl", we stop here.
    exit 1
  fi
  
  exit 1
}

#######################################
# ListInstalledPipelines
#
# Goal: List Installed Pipelines.
# Input: 
# Output: [{"PipelineName": "%s", "Enabled": "%bool"}]
#######################################
function ListInstalledPipelines() {
  local OC_CONFIG=""
  local name_regex="name: (\S*)"
  local disabled_regex="disabled: (\S*)"
  local found_pipeline_name=""
  local found_pipeline_disabled=""
  local found_pipeline_enabled=""
  local oc_pipelines_table="["

  # First establish if "lrctl" is present and running
  local lrctl_present=1
  ./lrctl --help >/dev/null 2>/dev/null || lrctl_present=-1

  if [ $lrctl_present -eq 1 ]; then
    # "lrctl"is present.
    OC_CONFIG=$(./lrctl open-collector config export 2>/dev/null) || OC_CONFIG=""
    #OC_CONFIG=$(cat oc_conf.txt 2>/dev/null) || OC_CONFIG=""

    local regex="[^ ](pipelines:(.*))quarantine:"
    if [[ $OC_CONFIG =~ $regex ]]
    then
      # Put our finding into $oc_pipelines
    local oc_pipelines=""
    oc_pipelines=${BASH_REMATCH[2]}
    # Filter out eveything that is not "name:" or "disabled:"
    oc_pipelines=$(echo "$oc_pipelines" | grep -i "name:\|disabled:")
      #echo "$oc_pipelines"

    #err "Searching Pipelines... ==========="
      regex="(- (name: \S*)|(disabled: \S*))(\s+  (name: \S*)|(disabled: \S*))?"
      
    local found_pipeline=""
    while [[ "$oc_pipelines" =~ $regex ]]; do
        found_pipeline=${BASH_REMATCH[0]}
        oc_pipelines=${oc_pipelines##*"$found_pipeline"}  # Remove the pipeline we just found

        #echo "======"
        #echo "$found_pipeline"

        # Extract the Name of the Pipeline
      if [[ "$found_pipeline" =~ $name_regex ]]
        then
          found_pipeline_name="${BASH_REMATCH[1]}"
          # Now let's look for a Disabled
      found_pipeline_disabled=""
      if [[ "$found_pipeline" =~ $disabled_regex ]]
          then
            found_pipeline_disabled="${BASH_REMATCH[1]}"
        fi
      # Bring it to Lower Case
      found_pipeline_disabled="${found_pipeline_disabled,,}"
      # Limit it to "true" or "false", and invert it as we need to report the ones that are Enabled
      if [ "$found_pipeline_disabled" != "true" ]; then
        found_pipeline_enabled="true"
      else
        found_pipeline_enabled="false"
      fi
          oc_pipelines_table+="{\"PipelineName\": \"$found_pipeline_name\", \"Enabled\": \"$found_pipeline_enabled\"}"
      #else
          # Well, no Name for this pipeline. Odd, but let's ignore and pass to the next one.
      #err "NO MATCH"
      fi

      done # while
    
    oc_pipelines_table=${oc_pipelines_table//$BACK_TO_BACK_BRACKETS/$BACK_TO_BACK_BRACKETS_WITH_COMMA}
      oc_pipelines_table+="]"

      echo -e "$oc_pipelines_table"
      exit 0
    fi

  else
    # No "lrctl", we stop here.
    echo -e "[]"
    exit 1
  fi
  
  exit 1
}

#######################################
# ListPipelineProjects
#
# Goal: List Pipeline Projects.
# Input: 
# Output: [{"PipelineProjectName": "%s"}]
#######################################
function ListPipelineProjects() {
  local pipelines_projects_table="["
  local pipeline_project_directory=""
  for pipeline_project_directory in `ls --directory  --width=800 -1 $PIPELINE_PROJECT_ROOT/*/ 2>/dev/null`
  do
    # Remove the $PIPELINE_PROJECT_ROOT from the full path
    pipeline_project_directory=${pipeline_project_directory##*"$PIPELINE_PROJECT_ROOT"}
    # Remove the trailing "/"
  pipeline_project_directory=${pipeline_project_directory%/}
    # Remove the heading "/"
  pipeline_project_directory=${pipeline_project_directory#/}
  # Add to the table
  pipelines_projects_table+="{\"PipelineProjectName\": \"$pipeline_project_directory\"}"
  done

  # Add the Commas to separate the entries
  pipelines_projects_table=${pipelines_projects_table//$BACK_TO_BACK_BRACKETS/$BACK_TO_BACK_BRACKETS_WITH_COMMA}
  pipelines_projects_table+="]"
  echo "$pipelines_projects_table"
  exit 0
}

#######################################
# GetPipelineProjectFilter
#
# Goal: Get Pipeline Project Filter.
# Input: {"ProjectName": "%s"}
# Output: %RawFilter%
#######################################
function GetPipelineProjectFilter() {
  local pipeline_project=""
  local pipeline_project_filter=""
  local regex='"ProjectName"\s*:\s*"([^"]*)"'
  if [[ "$1" =~ $regex ]]
    then
    pipeline_project="${BASH_REMATCH[1]}"
    pipeline_project_filter="$PIPELINE_PROJECT_ROOT/$pipeline_project/is_$pipeline_project.jq"
      cat "$pipeline_project_filter" 2>/dev/null
    exit 0
  fi
  exit 1
}

#######################################
# GetPipelineProjectTransform
#
# Goal: Get Pipeline Project Transform.
# Input: {"ProjectName": "%s"}
# Output: %RawTransform%
#######################################
function GetPipelineProjectTransform() {
  local pipeline_project=""
  local pipeline_project_transform=""
  local regex='"ProjectName"\s*:\s*"([^"]*)"'
  if [[ "$1" =~ $regex ]]
    then
    pipeline_project="${BASH_REMATCH[1]}"
    pipeline_project_transform="$PIPELINE_PROJECT_ROOT/$pipeline_project/$pipeline_project.jq"
    cat "$pipeline_project_transform" 2>/dev/null
    exit 0
  fi
  exit 1
}

#######################################
# InstallDocker
#
# Goal: Install Docker.
# Input: {"ExtraParameters": "%s_base64_encoded"}
# Output: {"Result": "%s_base64_encoded", "Error": "%s_base64_encoded"}
#######################################
function InstallDocker() {
  local output_result=""
  local output_error=""
  # First, get the Extra Parameters, if any.
  local extra_parameters=""
  local regex='"ExtraParameters"\s*:\s*"([^"]*)"'
  if [[ "$1" =~ $regex ]]
    then
    extra_parameters="${BASH_REMATCH[1]}"
    extra_parameters=$(echo "$extra_parameters" | base64 --decode 2>/dev/null) || extra_parameters=""
  fi

  # ###############
  # Install time!

  # Prep the log files
  local log_files_root="$PROJECT_ROOT/OCHelper_logs"
  local install_utils_log="$log_files_root/install_utils.log"
  local install_docker_log="$log_files_root/install_docker.log"

  # Create Logs directory
  if [ ! -d "$log_files_root" ]; then
    mkdir "$log_files_root" 2>/dev/null
  fi

  # Clean any previous logs
  date --rfc-3339=seconds > "$install_utils_log"
  date --rfc-3339=seconds > "$install_docker_log"

  # Now call the installers
  local return_code=0
    
  if [ $return_code -eq 0 ]; then
    date --rfc-3339=seconds > "$install_utils_log"
    sudo -n yum install $extra_parameters --quiet --assumeyes yum-utils device-mapper-persistent-data lvm2 >>"$install_utils_log" 2>>"$install_utils_log" || return_code+=$?
    if [ $return_code -ne 0 ]; then
    output_error+="| \"yum-utils device-mapper-persistent-data lvm2\" : \"Failed to install.\" : Return code: \"$return_code\". |"
  fi
    output_result+="###############################"$'\n'"\"yum-utils device-mapper-persistent-data lvm2\""$'\n'"============="$'\n'
    output_result+=$(cat "$install_utils_log")
    output_result+=$'\n'"============="$'\n'$'\n'
  fi
    
  if [ $return_code -eq 0 ]; then
    date --rfc-3339=seconds > "$install_utils_log"
    sudo -n yum-config-manager $extra_parameters --quiet --assumeyes --add-repo https://download.docker.com/linux/centos/docker-ce.repo >>"$install_utils_log" 2>>"$install_utils_log" || return_code+=$?
    if [ $return_code -ne 0 ]; then
    output_error+="| \"yum-config-manager\" : \"Failed to install.\" : Return code: \"$return_code\". |"
  fi
    output_result+="###############################"$'\n'"\"yum-config-manager\""$'\n'"============="$'\n'
    output_result+=$(cat "$install_utils_log")
    output_result+=$'\n'"============="$'\n'$'\n'
  fi
  
  if [ $return_code -eq 0 ]; then
    date --rfc-3339=seconds > "$install_docker_log"
    sudo -n yum install $extra_parameters --quiet --assumeyes docker-ce docker-ce-cli containerd.io >>"$install_docker_log" 2>>"$install_docker_log" || return_code=+$?
    if [ $return_code -ne 0 ]; then
    output_error+="| \"docker-ce docker-ce-cli containerd.io\" : \"Failed to install.\" : Return code: \"$return_code\". |"
  fi
    output_result+="###############################"$'\n'"\"docker-ce docker-ce-cli containerd.io\""$'\n'"============="$'\n'
    output_result+=$(cat "$install_docker_log")
    output_result+=$'\n'"============="$'\n'$'\n'
  fi 
  
  if [ $return_code -eq 0 ]; then
    date --rfc-3339=seconds > "$install_docker_log"
    sudo -n systemctl start docker >>"$install_docker_log" 2>>"$install_docker_log" || return_code=+$?
    if [ $return_code -ne 0 ]; then
    output_error+="| \"systemctl start docker\" : \"Failed.\" : Return code: \"$return_code\". |"
  fi
    output_result+="###############################"$'\n'"\"systemctl start docker\""$'\n'"============="$'\n'
    output_result+=$(cat "$install_docker_log")
    output_result+=$'\n'"============="$'\n'$'\n'
  fi

  if [ $return_code -eq 0 ]; then
    date --rfc-3339=seconds > "$install_docker_log"
    sudo -n systemctl enable docker >>"$install_docker_log" 2>>"$install_docker_log" || return_code=+$?
    if [ $return_code -ne 0 ]; then
      output_error+="| \"systemctl enable docker\" : \"Failed.\" : Return code: \"$return_code\". |"
  fi
    output_result+="###############################"$'\n'"\"systemctl enable docker\""$'\n'"============="$'\n'
    output_result+=$(cat "$install_docker_log")
    output_result+=$'\n'"============="$'\n'$'\n'
  fi

  if [ $return_code -eq 0 ]; then
    date --rfc-3339=seconds > "$install_docker_log"
    sudo -n usermod -aG docker $(whoami) >>"$install_docker_log" 2>>"$install_docker_log" || return_code=+$?
    if [ $return_code -ne 0 ]; then
      output_error+="| \"usermod -aG docker\" : \"Failed.\" : Return code: \"$return_code\". |"
  fi
    output_result+="###############################"$'\n'"\"usermod -aG docker\""$'\n'"============="$'\n'
    output_result+=$(cat "$install_docker_log")
    output_result+=$'\n'"============="$'\n'$'\n'
  fi

  if [ $return_code -eq 0 ]; then
    date --rfc-3339=seconds > "$install_docker_log"
    docker run hello-world >>"$install_docker_log" 2>>"$install_docker_log" || return_code=+$?
    if [ $return_code -ne 0 ]; then
      output_error+="| \"docker run hello-world\" : \"Failed.\" : Return code: \"$return_code\". |"
  fi
    output_result+="###############################"$'\n'"\"docker run hello-world\""$'\n'"============="$'\n'
    output_result+=$(cat "$install_docker_log")
    output_result+=$'\n'"============="$'\n'$'\n'
  fi

  # Prepare output
  output_result=$(echo -n "$output_result" | base64 --wrap=0)
  output_error=$(echo -n "$output_error" | base64 --wrap=0)
  echo -e "{\"Result\": \"$output_result\", \"Error\": \"$output_error\"}"

  if [ "$output_error" == "" ] ; then
    exit 0
  fi
  exit 1
}

#######################################
# UpgradeDocker
#
# Goal: Upgrade Docker.
# Input: {"ExtraParameters": "%s_base64_encoded"}
# Output: {"Result": "%s_base64_encoded", "Error": "%s_base64_encoded"}
#######################################
function UpgradeDocker() {
  local output_result=""
  local output_error=""
  # First, get the Extra Parameters, if any.
  local extra_parameters=""
  local regex='"ExtraParameters"\s*:\s*"([^"]*)"'
  if [[ "$1" =~ $regex ]]
    then
    extra_parameters="${BASH_REMATCH[1]}"
    extra_parameters=$(echo "$extra_parameters" | base64 --decode 2>/dev/null) || extra_parameters=""
  fi

  # First, check Docker is already installed
  local result=0
  docker -v >/dev/null 2>/dev/null || result=$?

  if [ $result -eq 0 ]; then
    # ###############
    # Upgrade time!

    # Prep the log files
    local log_files_root="$PROJECT_ROOT/OCHelper_logs"
    local upgrade_utils_log="$log_files_root/upgrade_utils.log"
    local upgrade_docker_log="$log_files_root/upgrade_docker.log"

    # Create Logs directory
    if [ ! -d "$log_files_root" ]; then
    mkdir "$log_files_root" 2>/dev/null
    fi

    # Clean any previous logs
    date --rfc-3339=seconds > "$upgrade_utils_log"
    date --rfc-3339=seconds > "$upgrade_docker_log"

    # Now call the installers
    local return_code=0
    
    if [ $return_code -eq 0 ]; then
    date --rfc-3339=seconds > "$upgrade_docker_log"
    sudo -n systemctl stop docker >>"$upgrade_docker_log" 2>>"$upgrade_docker_log" || return_code=+$?
    if [ $return_code -ne 0 ]; then
      output_error+="| \"systemctl stop docker\" : \"Failed.\" : Return code: \"$return_code\". |"
    fi
    output_result+="###############################"$'\n'"\"systemctl stop docker\""$'\n'"============="$'\n'
    output_result+=$(cat "$upgrade_docker_log")
    output_result+=$'\n'"============="$'\n'$'\n'
    fi

    if [ $return_code -eq 0 ]; then
    date --rfc-3339=seconds > "$upgrade_utils_log"
    sudo -n yum update $extra_parameters --quiet --assumeyes yum-utils device-mapper-persistent-data lvm2 >>"$upgrade_utils_log" 2>>"$upgrade_utils_log" || return_code+=$?
    if [ $return_code -ne 0 ]; then
      output_error+="| \"yum-utils device-mapper-persistent-data lvm2\" : \"Failed to upgrade.\" : Return code: \"$return_code\". |"
    fi
    output_result+="###############################"$'\n'"\"yum-utils device-mapper-persistent-data lvm2\""$'\n'"============="$'\n'
    output_result+=$(cat "$upgrade_utils_log")
    output_result+=$'\n'"============="$'\n'$'\n'
    fi
    
    if [ $return_code -eq 0 ]; then
    date --rfc-3339=seconds > "$upgrade_utils_log"
    sudo -n yum-config-manager $extra_parameters --quiet --assumeyes --add-repo https://download.docker.com/linux/centos/docker-ce.repo >>"$upgrade_utils_log" 2>>"$upgrade_utils_log" || return_code+=$?
    if [ $return_code -ne 0 ]; then
      output_error+="| \"yum-config-manager\" : \"Failed to add Repository.\" : Return code: \"$return_code\". |"
    fi
    output_result+="###############################"$'\n'"\"yum-config-manager\""$'\n'"============="$'\n'
    output_result+=$(cat "$upgrade_utils_log")
    output_result+=$'\n'"============="$'\n'$'\n'
    fi
    
    if [ $return_code -eq 0 ]; then
    date --rfc-3339=seconds > "$upgrade_docker_log"
    sudo -n yum update $extra_parameters --quiet --assumeyes docker-ce docker-ce-cli containerd.io >>"$upgrade_docker_log" 2>>"$upgrade_docker_log" || return_code=+$?
    if [ $return_code -ne 0 ]; then
      output_error+="| \"docker-ce docker-ce-cli containerd.io\" : \"Failed to upgrade.\" : Return code: \"$return_code\". |"
    fi
    output_result+="###############################"$'\n'"\"docker-ce docker-ce-cli containerd.io\""$'\n'"============="$'\n'
    output_result+=$(cat "$upgrade_docker_log")
    output_result+=$'\n'"============="$'\n'$'\n'
    fi 
    
    if [ $return_code -eq 0 ]; then
    date --rfc-3339=seconds > "$upgrade_docker_log"
    sudo -n systemctl start docker >>"$upgrade_docker_log" 2>>"$upgrade_docker_log" || return_code=+$?
    if [ $return_code -ne 0 ]; then
      output_error+="| \"systemctl start docker\" : \"Failed.\" : Return code: \"$return_code\". |"
    fi
    output_result+="###############################"$'\n'"\"systemctl start docker\""$'\n'"============="$'\n'
    output_result+=$(cat "$upgrade_docker_log")
    output_result+=$'\n'"============="$'\n'$'\n'
    fi

    if [ $return_code -eq 0 ]; then
    date --rfc-3339=seconds > "$upgrade_docker_log"
    sudo -n systemctl enable docker >>"$upgrade_docker_log" 2>>"$upgrade_docker_log" || return_code=+$?
    if [ $return_code -ne 0 ]; then
      output_error+="| \"systemctl enable docker\" : \"Failed.\" : Return code: \"$return_code\". |"
    fi
    output_result+="###############################"$'\n'"\"systemctl enable docker\""$'\n'"============="$'\n'
    output_result+=$(cat "$upgrade_docker_log")
    output_result+=$'\n'"============="$'\n'$'\n'
    fi

    if [ $return_code -eq 0 ]; then
    date --rfc-3339=seconds > "$upgrade_docker_log"
    docker run hello-world >>"$upgrade_docker_log" 2>>"$upgrade_docker_log" || return_code=+$?
    if [ $return_code -ne 0 ]; then
      output_error+="| \"docker run hello-world\" : \"Failed.\" : Return code: \"$return_code\". |"
    fi
    output_result+="###############################"$'\n'"\"docker run hello-world\""$'\n'"============="$'\n'
    output_result+=$(cat "$upgrade_docker_log")
    output_result+=$'\n'"============="$'\n'$'\n'
    fi
  else
    output_error+="| \"docker -v\" : \"Failed. No Docker present on this machine. Nothing to upgrade.\" : Return code: \"1\". |"
  fi

  # Prepare output
  output_result=$(echo -n "$output_result" | base64 --wrap=0)
  output_error=$(echo -n "$output_error" | base64 --wrap=0)
  echo -e "{\"Result\": \"$output_result\", \"Error\": \"$output_error\"}"

  if [ "$output_error" == "" ] ; then
    exit 0
  fi
  exit 1
}

#######################################
# DeployLatestLrctl
#
# Goal: Deploy Latest lrctl.
# Input: {"ExtraRepositories": [{"URL":"%s"}]}
# Output: {"Result": "%s_base64_encoded", "Error": "%s_base64_encoded"}
#######################################
function DeployLatestLrctl() {
  # Prep the log files
  local log_files_root="$PROJECT_ROOT/OCHelper_logs"
  local install_tmp_log="$log_files_root/install_tmp.log"

  # Create Logs directory
  if [ ! -d "$log_files_root" ]; then
    mkdir "$log_files_root" 2>/dev/null
  fi

  # First, get the Repositories sorted, including the Extra Repositories, if any.
  local extra_repositories=""
  local repositories_list=""
  repositories_list+="wget --timeout=10 --tries=3 --output-document=lrctl.zip \"http://tiny.cc/lrctl-zip-repo01\"  >>\"$install_tmp_log\" 2>>\"$install_tmp_log\""
  repositories_list+=" || wget --timeout=10 --tries=3 --output-document=lrctl.zip \"http://tiny.cc/lrctl-zip-repo02\" >>\"$install_tmp_log\" 2>>\"$install_tmp_log\""
  # Short URL:
  #  http://tiny.cc/lrctl-zip-repo01
  # points to:
  #  https://logrhythm.box.com/shared/static/jchs9u5djkidnky6n9zsf4rseiu1jiw5.zip

  local regex='"ExtraRepositories"\s*:\s*\[([^]]*)\]'
#  regex='\{"(URL)"'
    
  if [[ "$1" =~ $regex ]]
    then
    extra_repositories="${BASH_REMATCH[1]}"
    #echo -e "Extra Repo: $extra_repositories"
    if [ "$extra_repositories" != "" ] ; then
      # Split the /*atoms*/ URLs !
      echo "Found URLs"
        # Find the URL JSON block
        regex='(\{"URL"\s*:\s*"[^"]*"\},?)'
      
      local found_url=""
      while [[ "$extra_repositories" =~ $regex ]]; do
          found_url=${BASH_REMATCH[0]}
          extra_repositories=${extra_repositories##*"$found_url"}  # Remove the bit we just found

          #echo "======"
          #echo "Found_url: $found_url"
          local url_regex='\{"URL"\s*:\s*"([^"]*)"\}'
          # Extract the URI of the URL block
        if [[ "$found_url" =~ $url_regex ]]
          then
            found_url_uri="${BASH_REMATCH[1]}"
            #echo -e "found_url_uri: $found_url_uri"
            repositories_list+=" || wget --timeout=10 --tries=3 --output-document=lrctl.zip \"$found_url_uri\" >>\"$install_tmp_log\" 2>>\"$install_tmp_log\""
        #else
            # Well, no URI. Odd, but let's ignore and pass to the next one.
        #err "NO MATCH"
          fi

        done # while

    fi # if [ "$extra_repositories" != "" ] ; then
  fi # if [[ "$1" =~ $regex ]]
  
  #echo -e "repositories_list: $repositories_list"

  # Define our installation steps
  # First set of commands. See below for the rest.
  local install_steps=( 
                            "sudo -n yum install --quiet --assumeyes wget"
                            "sudo -n yum install --quiet --assumeyes unzip"
                            "rm --force lrctl.zip"
                            "$repositories_list" # This is expanded with all the Repositories. See above.
                            "unzip -u -qq -o lrctl.zip"
                            "md5sum --status --check lrctl.md5"
                            "md5sum --status --check lrctl.json.md5"
                            "rm --force lrctl.zip"
                            "chmod +x lrctl"
                           #"./lrctl update" # Not good, as this will fail if ran before "./lrctl init"
                           )
  local output_result=""
  local output_error=""

  # ###############
  # Install time!

  local return_code=0
  local install_steps_number=${#install_steps[@]}
  
  # Clean any previous logs
  date --rfc-3339=seconds > "$install_tmp_log"
  output_result+="###############################"$'\n'"### Steps: $install_steps_number ### Kicking off... ###"$'\n'"============="$'\n'
  output_result+=$(cat "$install_tmp_log")
  output_result+=$'\n'"============="$'\n'$'\n'

  # Now call the installers
  for (( install_step_id=1; install_step_id<=$install_steps_number; install_step_id++ ))
   do
    if [ $return_code -eq 0 ]; then
      date --rfc-3339=seconds > "$install_tmp_log"
      eval "${install_steps[$install_step_id-1]} >>\"$install_tmp_log\" 2>>\"$install_tmp_log\"" || return_code=$?
      if [ $return_code -ne 0 ]; then
     output_error+="| (Step: $install_step_id / $install_steps_number) | \"${install_steps[$install_step_id-1]}\" : \"Failed.\" : Return code: \"$return_code\". |"
      fi
      output_result+="###############################"$'\n'"## Step: $install_step_id / $install_steps_number"$'\n'"\"${install_steps[$install_step_id-1]}\""$'\n'"============="$'\n'
      output_result+=$(cat "$install_tmp_log")
      output_result+=$'\n'"============="$'\n'$'\n'
     fi
   done

  # Prepare output
  output_result=$(echo -n "$output_result" | base64 --wrap=0)
  output_error=$(echo -n "$output_error" | base64 --wrap=0)
  echo -e "{\"Result\": \"$output_result\", \"Error\": \"$output_error\"}"

  if [ "$output_error" == "" ] ; then
    exit 0
  fi
  exit 1
}

#######################################
# DeployLatestLRJQ
#
# Goal: Deploy Latest lrjq.
# Input: {"ExtraRepositories": [{"URL":"%s"}]}
# Output: {"Result": "%s_base64_encoded", "Error": "%s_base64_encoded"}
#######################################
function DeployLatestLRJQ() {
  # Prep the log files
  local log_files_root="$PROJECT_ROOT/OCHelper_logs"
  local install_tmp_log="$log_files_root/install_tmp.log"

  # Create Logs directory
  if [ ! -d "$log_files_root" ]; then
    mkdir "$log_files_root" 2>/dev/null
  fi

  # First, get the Repositories sorted, including the Extra Repositories, if any.
  local extra_repositories=""
  local repositories_list=""
  repositories_list+="wget --timeout=10 --tries=3 --output-document=lrjq.zip \"http://tiny.cc/lrjq-zip-repo01\"  >>\"$install_tmp_log\" 2>>\"$install_tmp_log\""
  repositories_list+=" || wget --timeout=10 --tries=3 --output-document=lrjq.zip \"http://tiny.cc/lrjq-zip-repo02\" >>\"$install_tmp_log\" 2>>\"$install_tmp_log\""
                 
  local regex='"ExtraRepositories"\s*:\s*\[([^]]*)\]'
  if [[ "$1" =~ $regex ]]
    then
    extra_repositories="${BASH_REMATCH[1]}"
    if [ "$extra_repositories" != "" ] ; then
      # Split the /*atoms*/ URLs !

        # Find the URL JSON block
        regex='(\{"URL"\s*:\s*"[^"]*"\},?)'
      
      local found_url=""
      while [[ "$extra_repositories" =~ $regex ]]; do
          found_url=${BASH_REMATCH[0]}
          extra_repositories=${extra_repositories##*"$found_url"}  # Remove the repository we just found

          #echo "======"
          #echo "$found_url"
          local url_regex='\{"URL"\s*:\s*"([^"]*)"\}'
          # Extract the URI of the URL block
        if [[ "$found_url" =~ $url_regex ]]
          then
            found_url_uri="${BASH_REMATCH[1]}"
            repositories_list+=" || wget --timeout=10 --tries=3 --output-document=lrjq.zip \"$found_url_uri\" >>\"$install_tmp_log\" 2>>\"$install_tmp_log\""
        #else
            # Well, no URI. Odd, but let's ignore and pass to the next one.
        #err "NO MATCH"
          fi

        done # while

    fi # if [ "$extra_repositories" != "" ] ; then
  fi # if [[ "$1" =~ $regex ]]

  # Define our installation steps
  # First set of commands. See below for the rest.
  local install_steps=( 
                            "sudo -n yum install $extra_parameters --quiet --assumeyes wget"
                            "sudo -n yum install $extra_parameters --quiet --assumeyes unzip"
                            "rm --force lrjq.zip"
                            "$repositories_list" # This is expanded with all the Repositories. See above.
                            "unzip -u -qq -o lrjq.zip"
                            "md5sum --status --check lrjq.md5"
                            "rm --force lrjq.zip"
                            "chmod +x lrjq"
                           )
  local output_result=""
  local output_error=""

  # ###############
  # Install time!

  local return_code=0
  local install_steps_number=${#install_steps[@]}
  
  # Clean any previous logs
  date --rfc-3339=seconds > "$install_tmp_log"
  output_result+="###############################"$'\n'"### Steps: $install_steps_number ### Kicking off... ###"$'\n'"============="$'\n'
  output_result+=$(cat "$install_tmp_log")
  output_result+=$'\n'"============="$'\n'$'\n'

  # Now call the installers
  for (( install_step_id=1; install_step_id<=$install_steps_number; install_step_id++ ))
   do
    if [ $return_code -eq 0 ]; then
      date --rfc-3339=seconds > "$install_tmp_log"
      eval "${install_steps[$install_step_id-1]} >>\"$install_tmp_log\" 2>>\"$install_tmp_log\"" || return_code=$?
      if [ $return_code -ne 0 ]; then
     output_error+="| (Step: $install_step_id / $install_steps_number) | \"${install_steps[$install_step_id-1]}\" : \"Failed.\" : Return code: \"$return_code\". |"
      fi
      output_result+="###############################"$'\n'"## Step: $install_step_id / $install_steps_number"$'\n'"\"${install_steps[$install_step_id-1]}\""$'\n'"============="$'\n'
      output_result+=$(cat "$install_tmp_log")
      output_result+=$'\n'"============="$'\n'$'\n'
     fi
   done

  # Prepare output
  output_result=$(echo -n "$output_result" | base64 --wrap=0)
  output_error=$(echo -n "$output_error" | base64 --wrap=0)
  echo -e "{\"Result\": \"$output_result\", \"Error\": \"$output_error\"}"

  if [ "$output_error" == "" ] ; then
    exit 0
  fi
  exit 1
}

#######################################
# DeployLatestOcpipeline
#
# Goal: Deploy Latest ocpipeline.
# Input: {"ExtraRepositories": [{"URL":"%s"}]}
# Output: {"Result": "%s_base64_encoded", "Error": "%s_base64_encoded"}
#######################################
function DeployLatestOcpipeline() {
  # Prep the log files
  local log_files_root="$PROJECT_ROOT/OCHelper_logs"
  local install_tmp_log="$log_files_root/install_tmp.log"

  # Create Logs directory
  if [ ! -d "$log_files_root" ]; then
    mkdir "$log_files_root" 2>/dev/null
  fi

  # First, get the Repositories sorted, including the Extra Repositories, if any.
  local extra_repositories=""
  local repositories_list=""
  repositories_list+="wget --timeout=10 --tries=3 --output-document=ocpipeline.zip \"http://tiny.cc/ocpipeline-zip-repo01\"  >>\"$install_tmp_log\" 2>>\"$install_tmp_log\""
  repositories_list+=" || wget --timeout=10 --tries=3 --output-document=ocpipeline.zip \"http://tiny.cc/ocpipeline-zip-repo02\" >>\"$install_tmp_log\" 2>>\"$install_tmp_log\""
                 
  local regex='"ExtraRepositories"\s*:\s*\[([^]]*)\]'
  if [[ "$1" =~ $regex ]]
    then
    extra_repositories="${BASH_REMATCH[1]}"
    if [ "$extra_repositories" != "" ] ; then
      # Split the /*atoms*/ URLs !

        # Find the URL JSON block
        regex='(\{"URL"\s*:\s*"[^"]*"\},?)'
      
      local found_url=""
      while [[ "$extra_repositories" =~ $regex ]]; do
          found_url=${BASH_REMATCH[0]}
          extra_repositories=${extra_repositories##*"$found_url"}  # Remove the repository we just found

          #echo "======"
          #echo "$found_url"
          local url_regex='\{"URL"\s*:\s*"([^"]*)"\}'
          # Extract the URI of the URL block
        if [[ "$found_url" =~ $url_regex ]]
          then
            found_url_uri="${BASH_REMATCH[1]}"
            repositories_list+=" || wget --timeout=10 --tries=3 --output-document=ocpipeline.zip \"$found_url_uri\" >>\"$install_tmp_log\" 2>>\"$install_tmp_log\""
        #else
            # Well, no URI. Odd, but let's ignore and pass to the next one.
        #err "NO MATCH"
          fi

        done # while

    fi # if [ "$extra_repositories" != "" ] ; then
  fi # if [[ "$1" =~ $regex ]]

  # Define our installation steps
  # First set of commands. See below for the rest.
  local install_steps=( 
                            "sudo -n yum install $extra_parameters --quiet --assumeyes wget"
                            "sudo -n yum install $extra_parameters --quiet --assumeyes unzip"
                            "rm --force ocpipeline.zip"
                            "$repositories_list" # This is expanded with all the Repositories. See above.
                            "unzip -u -qq -o ocpipeline.zip"
                            "md5sum --status --check ocpipeline.md5"
                            "rm --force ocpipeline.zip"
                            "chmod +x ocpipeline"
                           )
  local output_result=""
  local output_error=""

  # ###############
  # Install time!

  # Prep the log files
  local log_files_root="$PROJECT_ROOT/OCHelper_logs"
  local install_tmp_log="$log_files_root/install_tmp.log"

  # Create Logs directory
  if [ ! -d "$log_files_root" ]; then
    mkdir "$log_files_root" 2>/dev/null
  fi

  local return_code=0
  local install_steps_number=${#install_steps[@]}
  
  # Clean any previous logs
  date --rfc-3339=seconds > "$install_tmp_log"
  output_result+="###############################"$'\n'"### Steps: $install_steps_number ### Kicking off... ###"$'\n'"============="$'\n'
  output_result+=$(cat "$install_tmp_log")
  output_result+=$'\n'"============="$'\n'$'\n'

  # Now call the installers
  for (( install_step_id=1; install_step_id<=$install_steps_number; install_step_id++ ))
   do
    if [ $return_code -eq 0 ]; then
      date --rfc-3339=seconds > "$install_tmp_log"
      eval "${install_steps[$install_step_id-1]} >>\"$install_tmp_log\" 2>>\"$install_tmp_log\"" || return_code=$?
      if [ $return_code -ne 0 ]; then
     output_error+="| (Step: $install_step_id / $install_steps_number) | \"${install_steps[$install_step_id-1]}\" : \"Failed.\" : Return code: \"$return_code\". |"
      fi
      output_result+="###############################"$'\n'"## Step: $install_step_id / $install_steps_number"$'\n'"\"${install_steps[$install_step_id-1]}\""$'\n'"============="$'\n'
      output_result+=$(cat "$install_tmp_log")
      output_result+=$'\n'"============="$'\n'$'\n'
     fi
   done

  # Prepare output
  output_result=$(echo -n "$output_result" | base64 --wrap=0)
  output_error=$(echo -n "$output_error" | base64 --wrap=0)
  echo -e "{\"Result\": \"$output_result\", \"Error\": \"$output_error\"}"

  if [ "$output_error" == "" ] ; then
    exit 0
  fi
  exit 1
}

#######################################
# InstallOC
#
# Goal: Install OC.
# Input: {"ExtraParameters": "%s_base64_encoded"}
# Output: {"Result": "%s_base64_encoded", "Error": "%s_base64_encoded"}
#######################################
function InstallOC() {
  local output_result=""
  local output_error=""
  # First, get the Extra Parameters, if any.
  local extra_parameters=""
  local regex='"ExtraParameters"\s*:\s*"([^"]*)"'
  if [[ "$1" =~ $regex ]]
    then
    extra_parameters="${BASH_REMATCH[1]}"
    extra_parameters=$(echo "$extra_parameters" | base64 --decode 2>/dev/null) || extra_parameters=""
  fi

  # Prep the log files
  local log_files_root="$PROJECT_ROOT/OCHelper_logs"
  local install_tmp_log="$log_files_root/install_tmp.log"

  # Define our installation steps
  local install_steps=( 
                            "./lrctl init"
                            "./lrctl help"
                            "./lrctl metrics start"
                            "./lrctl open-collector stop >>\"$install_tmp_log\" 2>>\"$install_tmp_log\" || echo NothingToStop"
                            "cat oc.conf.VirginUTC.txt | ./lrctl open-collector config import"
                            "./lrctl open-collector start $extra_parameters"
                            "./lrctl open-collector status"
                            "./lrctl status"
                           )
  # ###############
  # Install time!

  # Create Logs directory
  if [ ! -d "$log_files_root" ]; then
    mkdir "$log_files_root" 2>/dev/null
  fi

  local return_code=0
  local install_steps_number=${#install_steps[@]}
  
  # Clean any previous logs
  date --rfc-3339=seconds > "$install_tmp_log"
  output_result+="###############################"$'\n'"### Steps: $install_steps_number ### Kicking off... ###"$'\n'"============="$'\n'
  output_result+=$(cat "$install_tmp_log")
  output_result+=$'\n'"============="$'\n'$'\n'

  # Now call the installers
  for (( install_step_id=1; install_step_id<=$install_steps_number; install_step_id++ ))
   do
    if [ $return_code -eq 0 ]; then
      date --rfc-3339=seconds > "$install_tmp_log"
      eval "${install_steps[$install_step_id-1]} >>\"$install_tmp_log\" 2>>\"$install_tmp_log\"" || return_code=$?
      if [ $return_code -ne 0 ]; then
        output_error+="| (Step: $install_step_id / $install_steps_number) | \"${install_steps[$install_step_id-1]}\" : \"Failed.\" : Return code: \"$return_code\". |"
      fi
      output_result+="###############################"$'\n'"## Step: $install_step_id / $install_steps_number"$'\n'"\"${install_steps[$install_step_id-1]}\""$'\n'"============="$'\n'
      output_result+=$(cat "$install_tmp_log")
      output_result+=$'\n'"============="$'\n'$'\n'
     fi
   done

  # Prepare output
  output_result=$(echo -n "$output_result" | base64 --wrap=0)
  output_error=$(echo -n "$output_error" | base64 --wrap=0)
  echo -e "{\"Result\": \"$output_result\", \"Error\": \"$output_error\"}"

  if [ "$output_error" == "" ] ; then
    exit 0
  fi
  exit 1
}

#######################################
# UpgradeOC
#
# Goal: Upgrade OC.
# Input: {"ExtraParameters": "%s_base64_encoded"}
# Output: {"Result": "%s_base64_encoded", "Error": "%s_base64_encoded"}
#######################################
function UpgradeOC() {
  RestartOC "$@"
}

#######################################
# RestartOC
#
# Goal: Restart OC.
# Input: {"ExtraParameters": "%s_base64_encoded"}
# Output: {"Result": "%s_base64_encoded", "Error": "%s_base64_encoded"}
#######################################
function RestartOC() {
  local output_result=""
  local output_error=""
  # First, get the Extra Parameters, if any.
  local extra_parameters=""
  local regex='"ExtraParameters"\s*:\s*"([^"]*)"'
  if [[ "$1" =~ $regex ]]
    then
    extra_parameters="${BASH_REMATCH[1]}"
    extra_parameters=$(echo "$extra_parameters" | base64 --decode 2>/dev/null) || extra_parameters=""
  fi

  # Define our installation steps
  local install_steps=( 
                            "./lrctl open-collector stop"
                            "./lrctl open-collector start $extra_parameters"
                            "./lrctl open-collector status"
                            "./lrctl status"
                           )

  # ###############
  # Install time!

  # Prep the log files
  local log_files_root="$PROJECT_ROOT/OCHelper_logs"
  local install_tmp_log="$log_files_root/install_tmp.log"

  # Create Logs directory
  if [ ! -d "$log_files_root" ]; then
    mkdir "$log_files_root" 2>/dev/null
  fi

  local return_code=0
  local install_steps_number=${#install_steps[@]}
  
  # Clean any previous logs
  date --rfc-3339=seconds > "$install_tmp_log"
  output_result+="###############################"$'\n'"### Steps: $install_steps_number ### Kicking off... ###"$'\n'"============="$'\n'
  output_result+=$(cat "$install_tmp_log")
  output_result+=$'\n'"============="$'\n'$'\n'

  # Now call the installers
  for (( install_step_id=1; install_step_id<=$install_steps_number; install_step_id++ ))
   do
    if [ $return_code -eq 0 ]; then
      date --rfc-3339=seconds > "$install_tmp_log"
      eval "${install_steps[$install_step_id-1]} >>\"$install_tmp_log\" 2>>\"$install_tmp_log\"" || return_code=$?
      if [ $return_code -ne 0 ]; then
     output_error+="| (Step: $install_step_id / $install_steps_number) | \"${install_steps[$install_step_id-1]}\" : \"Failed.\" : Return code: \"$return_code\". |"
      fi
      output_result+="###############################"$'\n'"## Step: $install_step_id / $install_steps_number"$'\n'"\"${install_steps[$install_step_id-1]}\""$'\n'"============="$'\n'
      output_result+=$(cat "$install_tmp_log")
      output_result+=$'\n'"============="$'\n'$'\n'
     fi
   done

  # Prepare output
  output_result=$(echo -n "$output_result" | base64 --wrap=0)
  output_error=$(echo -n "$output_error" | base64 --wrap=0)
  echo -e "{\"Result\": \"$output_result\", \"Error\": \"$output_error\"}"

  if [ "$output_error" == "" ] ; then
    exit 0
  fi
  exit 1
}

#######################################
# StartOC
#
# Goal: Start OC.
# Input: {"ExtraParameters": "%s_base64_encoded"}
# Output: {"Result": "%s_base64_encoded", "Error": "%s_base64_encoded"}
#######################################
function StartOC() {
  local output_result=""
  local output_error=""
  # First, get the Extra Parameters, if any.
  local extra_parameters=""
  local regex='"ExtraParameters"\s*:\s*"([^"]*)"'
  if [[ "$1" =~ $regex ]]
    then
    extra_parameters="${BASH_REMATCH[1]}"
    extra_parameters=$(echo "$extra_parameters" | base64 --decode 2>/dev/null) || extra_parameters=""
  fi

  # Define our installation steps
  local install_steps=( 
                            "./lrctl open-collector start $extra_parameters"
                            "./lrctl open-collector status"
                            "./lrctl status"
                           )

  # ###############
  # Install time!

  # Prep the log files
  local log_files_root="$PROJECT_ROOT/OCHelper_logs"
  local install_tmp_log="$log_files_root/install_tmp.log"

  # Create Logs directory
  if [ ! -d "$log_files_root" ]; then
    mkdir "$log_files_root" 2>/dev/null
  fi

  local return_code=0
  local install_steps_number=${#install_steps[@]}
  
  # Clean any previous logs
  date --rfc-3339=seconds > "$install_tmp_log"
  output_result+="###############################"$'\n'"### Steps: $install_steps_number ### Kicking off... ###"$'\n'"============="$'\n'
  output_result+=$(cat "$install_tmp_log")
  output_result+=$'\n'"============="$'\n'$'\n'

  # Now call the installers
  for (( install_step_id=1; install_step_id<=$install_steps_number; install_step_id++ ))
   do
    if [ $return_code -eq 0 ]; then
      date --rfc-3339=seconds > "$install_tmp_log"
      eval "${install_steps[$install_step_id-1]} >>\"$install_tmp_log\" 2>>\"$install_tmp_log\"" || return_code=$?
      if [ $return_code -ne 0 ]; then
     output_error+="| (Step: $install_step_id / $install_steps_number) | \"${install_steps[$install_step_id-1]}\" : \"Failed.\" : Return code: \"$return_code\". |"
      fi
      output_result+="###############################"$'\n'"## Step: $install_step_id / $install_steps_number"$'\n'"\"${install_steps[$install_step_id-1]}\""$'\n'"============="$'\n'
      output_result+=$(cat "$install_tmp_log")
      output_result+=$'\n'"============="$'\n'$'\n'
     fi
   done

  # Prepare output
  output_result=$(echo -n "$output_result" | base64 --wrap=0)
  output_error=$(echo -n "$output_error" | base64 --wrap=0)
  echo -e "{\"Result\": \"$output_result\", \"Error\": \"$output_error\"}"

  if [ "$output_error" == "" ] ; then
    exit 0
  fi
  exit 1
}

#######################################
# StopOC
#
# Goal: Stop OC.
# Input: {"ExtraParameters": "%s_base64_encoded"}
# Output: {"Result": "%s_base64_encoded", "Error": "%s_base64_encoded"}
#######################################
function StopOC() {
  local output_result=""
  local output_error=""
  # First, get the Extra Parameters, if any.
  local extra_parameters=""
  local regex='"ExtraParameters"\s*:\s*"([^"]*)"'
  if [[ "$1" =~ $regex ]]
    then
    extra_parameters="${BASH_REMATCH[1]}"
    extra_parameters=$(echo "$extra_parameters" | base64 --decode 2>/dev/null) || extra_parameters=""
  fi

  # Define our installation steps
  local install_steps=( 
                            "./lrctl open-collector stop $extra_parameters"
                            "./lrctl open-collector status"
                            "./lrctl status"
                           )

  # ###############
  # Install time!

  # Prep the log files
  local log_files_root="$PROJECT_ROOT/OCHelper_logs"
  local install_tmp_log="$log_files_root/install_tmp.log"

  # Create Logs directory
  if [ ! -d "$log_files_root" ]; then
    mkdir "$log_files_root" 2>/dev/null
  fi

  local return_code=0
  local install_steps_number=${#install_steps[@]}
  
  # Clean any previous logs
  date --rfc-3339=seconds > "$install_tmp_log"
  output_result+="###############################"$'\n'"### Steps: $install_steps_number ### Kicking off... ###"$'\n'"============="$'\n'
  output_result+=$(cat "$install_tmp_log")
  output_result+=$'\n'"============="$'\n'$'\n'

  # Now call the installers
  for (( install_step_id=1; install_step_id<=$install_steps_number; install_step_id++ ))
   do
    if [ $return_code -eq 0 ]; then
      date --rfc-3339=seconds > "$install_tmp_log"
      eval "${install_steps[$install_step_id-1]} >>\"$install_tmp_log\" 2>>\"$install_tmp_log\"" || return_code=$?
      if [ $return_code -ne 0 ]; then
     output_error+="| (Step: $install_step_id / $install_steps_number) | \"${install_steps[$install_step_id-1]}\" : \"Failed.\" : Return code: \"$return_code\". |"
      fi
      output_result+="###############################"$'\n'"## Step: $install_step_id / $install_steps_number"$'\n'"\"${install_steps[$install_step_id-1]}\""$'\n'"============="$'\n'
      output_result+=$(cat "$install_tmp_log")
      output_result+=$'\n'"============="$'\n'$'\n'
     fi
   done

  # Prepare output
  output_result=$(echo -n "$output_result" | base64 --wrap=0)
  output_error=$(echo -n "$output_error" | base64 --wrap=0)
  echo -e "{\"Result\": \"$output_result\", \"Error\": \"$output_error\"}"

  if [ "$output_error" == "" ] ; then
    exit 0
  fi
  exit 1
}

#######################################
# WriteOCConfiguration
#
# Goal: Write OC Configuration.
# Input: {"RawConfig": "%s_base64_encoded"}
# Output: {"Result": "%s_base64_encoded", "Error": "%s_base64_encoded"}
#######################################
function WriteOCConfiguration() {
  local output_result=""
  local output_error=""
  # First, get the RawConfig.
  local raw_config=""
  local regex='"RawConfig"\s*:\s*"([^"]*)"'
  if [[ "$1" =~ $regex ]]
    then
    raw_config="${BASH_REMATCH[1]}"
    raw_config=$(echo "$raw_config" | base64 --decode 2>/dev/null) || raw_config=""
  fi
  if [ "$raw_config" != "" ] ; then
      # Define our installation steps
      local install_steps=( 
                            "echo \"$raw_config\" | ./lrctl open-collector config import"
                           )

      # ###############
      # Install time!

      # Prep the log files
      local log_files_root="$PROJECT_ROOT/OCHelper_logs"
      local install_tmp_log="$log_files_root/install_tmp.log"

      # Create Logs directory
      if [ ! -d "$log_files_root" ]; then
        mkdir "$log_files_root" 2>/dev/null
      fi

      local return_code=0
      local install_steps_number=${#install_steps[@]}
  
      # Clean any previous logs
      date --rfc-3339=seconds > "$install_tmp_log"
      output_result+="###############################"$'\n'"### Steps: $install_steps_number ### Kicking off... ###"$'\n'"============="$'\n'
      output_result+=$(cat "$install_tmp_log")
      output_result+=$'\n'"============="$'\n'$'\n'

      # Now call the installers
      for (( install_step_id=1; install_step_id<=$install_steps_number; install_step_id++ ))
       do
        if [ $return_code -eq 0 ]; then
          date --rfc-3339=seconds > "$install_tmp_log"
          eval "${install_steps[$install_step_id-1]} >>\"$install_tmp_log\" 2>>\"$install_tmp_log\"" || return_code=$?
          if [ $return_code -ne 0 ]; then
         output_error+="| (Step: $install_step_id / $install_steps_number) | \"${install_steps[$install_step_id-1]}\" : \"Failed.\" : Return code: \"$return_code\". |"
          fi
          output_result+="###############################"$'\n'"## Step: $install_step_id / $install_steps_number"$'\n'"\"${install_steps[$install_step_id-1]}\""$'\n'"============="$'\n'
          output_result+=$(cat "$install_tmp_log")
          output_result+=$'\n'"============="$'\n'$'\n'
         fi
       done
  else
    output_error="Raw config not provided, or incorrect encoding (hint: it MUST be base64 encoded)."
  fi

  # Prepare output
  output_result=$(echo -n "$output_result" | base64 --wrap=0)
  output_error=$(echo -n "$output_error" | base64 --wrap=0)
  echo -e "{\"Result\": \"$output_result\", \"Error\": \"$output_error\"}"

  if [ "$output_error" == "" ] ; then
    exit 0
  fi
  exit 1
}

#######################################
# CreatePipelineProject
#
# Goal: Create new Pipeline project.
# Input: {"ProjectName": "%s"}
# Output: {"NewFullPath": "%s", "Result": "%s_base64_encoded", "Error": "%s_base64_encoded"}
#######################################
function CreatePipelineProject() {
  local output_result=""
  local output_error=""
  local pipeline_project_path=""

  # Check the parameters
  local regex='"ProjectName"\s*:\s*"([^"]*)"'
  if [[ "$1" =~ $regex ]]
    then
      local pipeline_project="${BASH_REMATCH[1]}"
      pipeline_project_path="$PIPELINE_PROJECT_ROOT/$pipeline_project"

      # Check if pipeline project already exists
      if [ ! -d "$pipeline_project_path" ]; then
        # it does NOT. Let's go ahead.
        
        # Define our installation steps
        local install_steps=( 
                              "[[ ! -d \"$PIPELINE_PROJECT_ROOT\" ]] && mkdir \"$PIPELINE_PROJECT_ROOT\" || echo \"Folder already exists. All good. Carry on.\""
                             #"cd \"$PIPELINE_PROJECT_ROOT\""
                              "./ocpipeline create --destination \"$PIPELINE_PROJECT_ROOT\" --name \"$pipeline_project\""
                              "ls -l \"$PIPELINE_PROJECT_ROOT\""
                             )

        # Prep the log files
        local log_files_root="$PROJECT_ROOT/OCHelper_logs"
        local install_tmp_log="$log_files_root/install_tmp.log"

        # Create Logs directory
        if [ ! -d "$log_files_root" ]; then
          mkdir "$log_files_root" 2>/dev/null
        fi

        local return_code=0
        local install_steps_number=${#install_steps[@]}
    
        # Clean any previous logs
        date --rfc-3339=seconds > "$install_tmp_log"
        output_result+="###############################"$'\n'"### Steps: $install_steps_number ### Kicking off... ###"$'\n'"============="$'\n'
        output_result+=$(cat "$install_tmp_log")
        output_result+=$'\n'"============="$'\n'$'\n'

        # Now call the Steps
        for (( install_step_id=1; install_step_id<=$install_steps_number; install_step_id++ ))
         do
          if [ $return_code -eq 0 ]; then
            date --rfc-3339=seconds > "$install_tmp_log"
            eval "${install_steps[$install_step_id-1]} >>\"$install_tmp_log\" 2>>\"$install_tmp_log\"" || return_code=$?
            if [ $return_code -ne 0 ]; then
           output_error+="| (Step: $install_step_id / $install_steps_number) | \"${install_steps[$install_step_id-1]}\" : \"Failed.\" : Return code: \"$return_code\". |"
            fi
            output_result+="###############################"$'\n'"## Step: $install_step_id / $install_steps_number"$'\n'"\"${install_steps[$install_step_id-1]}\""$'\n'"============="$'\n'
            output_result+=$(cat "$install_tmp_log")
            output_result+=$'\n'"============="$'\n'$'\n'
           fi
         done      
      else
        # it does.
        output_error="Pipeline Project already exists."
      fi
    else
      output_error="Parameter mis-formatted."
  fi

  # Prepping the output
  output_result=$(echo -n "$output_result" | base64 --wrap=0)
  output_error=$(echo -n "$output_error" | base64 --wrap=0)
  echo -e "{\"NewFullPath\": \"$pipeline_project_path\", \"Result\": \"$output_result\", \"Error\": \"$output_error\"}"

  if [ "$output_error" == "" ] ; then
    exit 0
  fi
  exit 1
}


#######################################
# UpdatePipelineProjectFilter
#
# Goal: Update Pipeline Project Filter.
# Input: {"ProjectName": "%s", "NewFilter": "%s_base64_encoded"}
# Output: {"Result": "%s_base64_encoded", "Error": "%s_base64_encoded"}
#######################################
function UpdatePipelineProjectFilter() {
  local output_result=""
  local output_error=""
  local pipeline_project_path=""

  # Check the parameters
  local regex='"ProjectName"\s*:\s*"([^"]*)"\s*,\s*"NewFilter"\s*:\s*"([^"]*)"'
  if [[ "$1" =~ $regex ]]
    then
    local pipeline_project="${BASH_REMATCH[1]}"
    local pipeline_project_filter_raw="${BASH_REMATCH[2]}"
    local pipeline_project_filter=""
    pipeline_project_filter=$(echo "$pipeline_project_filter_raw" | base64 --decode 2>/dev/null) || pipeline_project_filter=""
    if [ "$pipeline_project_filter" == "" ] ; then
      output_error="Filter must be provided, non-empty and encoded correctly (based64)."
    else # if [ "$pipeline_project_filter" == "" ] ; then

      pipeline_project_path="$PIPELINE_PROJECT_ROOT/$pipeline_project"
      # Check if pipeline project exists
      if [ -d "$pipeline_project_path" ]; then
        local pipeline_project_filter_path="$pipeline_project_path/is_$pipeline_project.jq"
        # Define our installation steps
        local install_steps=( 
                              "echo \"$pipeline_project_filter_raw\" | base64 --decode > $pipeline_project_filter_path"
                             )

        # Prep the log files
        local log_files_root="$PROJECT_ROOT/OCHelper_logs"
        local install_tmp_log="$log_files_root/install_tmp.log"

        # Create Logs directory
        if [ ! -d "$log_files_root" ]; then
          mkdir "$log_files_root" 2>/dev/null
        fi

        local return_code=0
        local install_steps_number=${#install_steps[@]}
    
        # Clean any previous logs
        date --rfc-3339=seconds > "$install_tmp_log"
        output_result+="###############################"$'\n'"### Steps: $install_steps_number ### Kicking off... ###"$'\n'"============="$'\n'
        output_result+=$(cat "$install_tmp_log")
        output_result+=$'\n'"============="$'\n'$'\n'

        # Now call the Steps
        for (( install_step_id=1; install_step_id<=$install_steps_number; install_step_id++ ))
         do
          if [ $return_code -eq 0 ]; then
            date --rfc-3339=seconds > "$install_tmp_log"
            eval "${install_steps[$install_step_id-1]} 2>>\"$install_tmp_log\"" || return_code=$?
            if [ $return_code -ne 0 ]; then
              output_error+="| (Step: $install_step_id / $install_steps_number) | \"${install_steps[$install_step_id-1]}\" : \"Failed.\" : Return code: \"$return_code\". |"
            fi
            output_result+="###############################"$'\n'"## Step: $install_step_id / $install_steps_number"$'\n'"\"${install_steps[$install_step_id-1]}\""$'\n'"============="$'\n'
            output_result+=$(cat "$install_tmp_log")
            output_result+=$'\n'"============="$'\n'$'\n'
           fi
         done      
      else # if [ -d "$pipeline_project_path" ]; then
        # it does.
        output_error="Pipeline Project doesn't exist."
      fi # if [ -d "$pipeline_project_path" ]; then

    
    fi # if [ "$pipeline_project_filter" == "" ] ; then
  else
      output_error="Parameter mis-formatted."
  fi

  # Prepping the output
  output_result=$(echo -n "$output_result" | base64 --wrap=0)
  output_error=$(echo -n "$output_error" | base64 --wrap=0)
  echo -e "{\"Result\": \"$output_result\", \"Error\": \"$output_error\"}"

  if [ "$output_error" == "" ] ; then
    exit 0
  fi
  exit 1
}

#######################################
# UpdatePipelineProjectTransform
#
# Goal: Update Pipeline Project Transform.
# Input: {"ProjectName": "%s", "NewTransform": "%s_base64_encoded"}
# Output: {"Result": "%s_base64_encoded", "Error": "%s_base64_encoded"}
#######################################
function UpdatePipelineProjectTransform() {
  local output_result=""
  local output_error=""
  local pipeline_project_path=""

  # Check the parameters
  local regex='"ProjectName"\s*:\s*"([^"]*)"\s*,\s*"NewTransform"\s*:\s*"([^"]*)"'
  if [[ "$1" =~ $regex ]]
    then
    local pipeline_project="${BASH_REMATCH[1]}"
    local pipeline_project_transform_raw="${BASH_REMATCH[2]}"
    local pipeline_project_transform=""
    pipeline_project_transform=$(echo "$pipeline_project_transform_raw" | base64 --decode 2>/dev/null) || pipeline_project_transform=""
    if [ "$pipeline_project_transform" == "" ] ; then
      output_error="Transform must be provided, non-empty and encoded correctly (based64)."
    else # if [ "$pipeline_project_transform" == "" ] ; then

      pipeline_project_path="$PIPELINE_PROJECT_ROOT/$pipeline_project"
      # Check if pipeline project exists
      if [ -d "$pipeline_project_path" ]; then
        local pipeline_project_transform_path="$pipeline_project_path/$pipeline_project.jq"
        # Define our installation steps
        local install_steps=( 
                              "echo \"$pipeline_project_transform_raw\" | base64 --decode > $pipeline_project_transform_path"
                             )

        # Prep the log files
        local log_files_root="$PROJECT_ROOT/OCHelper_logs"
        local install_tmp_log="$log_files_root/install_tmp.log"

        # Create Logs directory
        if [ ! -d "$log_files_root" ]; then
          mkdir "$log_files_root" 2>/dev/null
        fi

        local return_code=0
        local install_steps_number=${#install_steps[@]}
    
        # Clean any previous logs
        date --rfc-3339=seconds > "$install_tmp_log"
        output_result+="###############################"$'\n'"### Steps: $install_steps_number ### Kicking off... ###"$'\n'"============="$'\n'
        output_result+=$(cat "$install_tmp_log")
        output_result+=$'\n'"============="$'\n'$'\n'

        # Now call the Steps
        for (( install_step_id=1; install_step_id<=$install_steps_number; install_step_id++ ))
         do
          if [ $return_code -eq 0 ]; then
            date --rfc-3339=seconds > "$install_tmp_log"
            eval "${install_steps[$install_step_id-1]} 2>>\"$install_tmp_log\"" || return_code=$?
            if [ $return_code -ne 0 ]; then
              output_error+="| (Step: $install_step_id / $install_steps_number) | \"${install_steps[$install_step_id-1]}\" : \"Failed.\" : Return code: \"$return_code\". |"
            fi
            output_result+="###############################"$'\n'"## Step: $install_step_id / $install_steps_number"$'\n'"\"${install_steps[$install_step_id-1]}\""$'\n'"============="$'\n'
            output_result+=$(cat "$install_tmp_log")
            output_result+=$'\n'"============="$'\n'$'\n'
           fi
         done      
      else # if [ -d "$pipeline_project_path" ]; then
        # it does.
        output_error="Pipeline Project doesn't exist."
      fi # if [ -d "$pipeline_project_path" ]; then

    
    fi # if [ "$pipeline_project_filter" == "" ] ; then
  else
      output_error="Parameter mis-formatted."
  fi

  # Prepping the output
  output_result=$(echo -n "$output_result" | base64 --wrap=0)
  output_error=$(echo -n "$output_error" | base64 --wrap=0)
  echo -e "{\"Result\": \"$output_result\", \"Error\": \"$output_error\"}"

  if [ "$output_error" == "" ] ; then
    exit 0
  fi
  exit 1
}


#######################################
# PackagePipelineProject
#
# Goal: Package Pipeline Project.
# Input: {"ProjectName": "%s"}
# Output: {"Result": "%s_base64_encoded", "Error": "%s_base64_encoded"}
#######################################
function PackagePipelineProject() {
  local output_result=""
  local output_error=""
  local pipeline_project_path=""

  # Check the parameters
  local regex='"ProjectName"\s*:\s*"([^"]*)"'
  if [[ "$1" =~ $regex ]]
    then
      local pipeline_project="${BASH_REMATCH[1]}"
      pipeline_project_path="$PIPELINE_PROJECT_ROOT/$pipeline_project"

      # Check if pipeline project exists
      if [ ! -d "$pipeline_project_path" ]; then
        # it does.
        output_error="Pipeline Project doesn't exist."
      else
        # it does. Let's go ahead.
        
        # Prep the log files
        local log_files_root="$PROJECT_ROOT/OCHelper_logs"
        local install_tmp_log="$log_files_root/install_tmp.log"

        # Define our installation steps
        local install_steps=(
                             "[[ -f \"$PIPELINE_PROJECT_ROOT/$pipeline_project.pipe\" ]] && rm --force \"$PIPELINE_PROJECT_ROOT/$pipeline_project.pipe\" && echo \"Existing Pipeline ($pipeline_project.pipe) file found. Deleting before creating the new one.\"  >>\"$install_tmp_log\" 2>>\"$install_tmp_log\" || echo \"No Pipeline ($pipeline_project.pipe) file found. All good. Carrying on.\""
                             #"cd \"$PIPELINE_PROJECT_ROOT\""
                              "./ocpipeline package --output_dir \"$PIPELINE_PROJECT_ROOT\" --source \"$pipeline_project_path\""
                              "ls -l \"$PIPELINE_PROJECT_ROOT\""
                             )

        # Create Logs directory
        if [ ! -d "$log_files_root" ]; then
          mkdir "$log_files_root" 2>/dev/null
        fi

        local return_code=0
        local install_steps_number=${#install_steps[@]}
    
        # Clean any previous logs
        date --rfc-3339=seconds > "$install_tmp_log"
        output_result+="###############################"$'\n'"### Steps: $install_steps_number ### Kicking off... ###"$'\n'"============="$'\n'
        output_result+=$(cat "$install_tmp_log")
        output_result+=$'\n'"============="$'\n'$'\n'

        # Now call the Steps
        for (( install_step_id=1; install_step_id<=$install_steps_number; install_step_id++ ))
         do
          if [ $return_code -eq 0 ]; then
            date --rfc-3339=seconds > "$install_tmp_log"
            eval "${install_steps[$install_step_id-1]} >>\"$install_tmp_log\" 2>>\"$install_tmp_log\"" || return_code=$?
            if [ $return_code -ne 0 ]; then
           output_error+="| (Step: $install_step_id / $install_steps_number) | \"${install_steps[$install_step_id-1]}\" : \"Failed.\" : Return code: \"$return_code\". |"
            fi
            output_result+="###############################"$'\n'"## Step: $install_step_id / $install_steps_number"$'\n'"\"${install_steps[$install_step_id-1]}\""$'\n'"============="$'\n'
            output_result+=$(cat "$install_tmp_log")
            output_result+=$'\n'"============="$'\n'$'\n'
           fi
         done      
      fi
    else
      output_error="Parameter mis-formatted."
  fi

  # Prepping the output
  output_result=$(echo -n "$output_result" | base64 --wrap=0)
  output_error=$(echo -n "$output_error" | base64 --wrap=0)
  echo -e "{\"Result\": \"$output_result\", \"Error\": \"$output_error\"}"

  if [ "$output_error" == "" ] ; then
    exit 0
  fi
  exit 1
}

#######################################
# InstallPipelinePackage
#
# Goal: Install Pipeline Package.
# Input: {"ProjectName": "%s"}
# Output: {"Result": "%s_base64_encoded", "Error": "%s_base64_encoded"}
#######################################
function InstallPipelinePackage() {
  local output_result=""
  local output_error=""
  local pipeline_project_path=""

  # Check the parameters
  local regex='"ProjectName"\s*:\s*"([^"]*)"'
  if [[ "$1" =~ $regex ]]
    then
      local pipeline_project="${BASH_REMATCH[1]}"
      pipeline_project_path="$PIPELINE_PROJECT_ROOT/$pipeline_project"

      # Check if pipeline project exists
      if [ ! -d "$pipeline_project_path" ]; then
        # it does.
        output_error="Pipeline Project doesn't exist."
      else
        # it does. Let's go ahead.
        
        # Define our installation steps
        local install_steps=( 
                             #"[[ -f \"$PIPELINE_PROJECT_ROOT/$pipeline_project.pipe\" ]] && rm --force \"$PIPELINE_PROJECT_ROOT/$pipeline_project.pipe\" && echo \"Existing Pipeline ($pipeline_project.pipe) file found. Deleting before creating the new one.\"|| echo \"No Pipeline ($pipeline_project.pipe) file found. All good. Carrying on.\""
                             #"cd \"$PIPELINE_PROJECT_ROOT\""
                              "cat \"$PIPELINE_PROJECT_ROOT/$pipeline_project.pipe\" | ./lrctl open-collector pipe import"
                             #"ls -l \"$PIPELINE_PROJECT_ROOT\""
                             )

        # Prep the log files
        local log_files_root="$PROJECT_ROOT/OCHelper_logs"
        local install_tmp_log="$log_files_root/install_tmp.log"

        # Create Logs directory
        if [ ! -d "$log_files_root" ]; then
          mkdir "$log_files_root" 2>/dev/null
        fi

        local return_code=0
        local install_steps_number=${#install_steps[@]}
    
        # Clean any previous logs
        date --rfc-3339=seconds > "$install_tmp_log"
        output_result+="###############################"$'\n'"### Steps: $install_steps_number ### Kicking off... ###"$'\n'"============="$'\n'
        output_result+=$(cat "$install_tmp_log")
        output_result+=$'\n'"============="$'\n'$'\n'

        # Now call the Steps
        for (( install_step_id=1; install_step_id<=$install_steps_number; install_step_id++ ))
         do
          if [ $return_code -eq 0 ]; then
            date --rfc-3339=seconds > "$install_tmp_log"
            eval "${install_steps[$install_step_id-1]} >>\"$install_tmp_log\" 2>>\"$install_tmp_log\"" || return_code=$?
            if [ $return_code -ne 0 ]; then
           output_error+="| (Step: $install_step_id / $install_steps_number) | \"${install_steps[$install_step_id-1]}\" : \"Failed.\" : Return code: \"$return_code\". |"
            fi
            output_result+="###############################"$'\n'"## Step: $install_step_id / $install_steps_number"$'\n'"\"${install_steps[$install_step_id-1]}\""$'\n'"============="$'\n'
            output_result+=$(cat "$install_tmp_log")
            output_result+=$'\n'"============="$'\n'$'\n'
           fi
         done      
      fi
    else
      output_error="Parameter mis-formatted."
  fi

  # Prepping the output
  output_result=$(echo -n "$output_result" | base64 --wrap=0)
  output_error=$(echo -n "$output_error" | base64 --wrap=0)
  echo -e "{\"Result\": \"$output_result\", \"Error\": \"$output_error\"}"

  if [ "$output_error" == "" ] ; then
    exit 0
  fi
  exit 1
}

#######################################
# TestPipelineProjectFilter
#
# Goal: Test Pipeline Project Filter.
# Input: {"ProjectName": "%s", "LogToTest": "%s_base64_encoded"}
# Output: {"Result": "%s_base64_encoded", "Error": "%s_base64_encoded"}
#######################################
function TestPipelineProjectFilter() {
  local output_result=""
  local output_error=""
  local pipeline_project_path=""

  # Check the parameters
  local regex='"ProjectName"\s*:\s*"([^"]*)"\s*,\s*"LogToTest"\s*:\s*"([^"]*)"'
  if [[ "$1" =~ $regex ]]
    then
    local pipeline_project="${BASH_REMATCH[1]}"
    local log_to_test_raw="${BASH_REMATCH[2]}"
    local log_to_test=""

    log_to_test=$(echo "$log_to_test_raw" | base64 --decode 2>/dev/null) || log_to_test=""
    if [ "$log_to_test" == "" ] ; then
      output_error="Log must be provided, non-empty and encoded correctly (based64)."
    else # if [ "$log_to_test" == "" ] ; then

      pipeline_project_path="$PIPELINE_PROJECT_ROOT/$pipeline_project"
      # Check if pipeline project exists
      if [ -d "$pipeline_project_path" ]; then
        local pipeline_project_filter_path="$pipeline_project_path/include.jq"

        # Prep the log files
        local log_files_root="$PROJECT_ROOT/OCHelper_logs"
        local install_tmp_log="$log_files_root/install_tmp.log"

        # Create Logs directory
        if [ ! -d "$log_files_root" ]; then
          mkdir "$log_files_root" 2>/dev/null
        fi

        # Define our installation steps
        local install_steps=( 
                              "echo -n \"LRJQ_Parsing_Result: \" >>\"$install_tmp_log\" && echo \"$log_to_test_raw\" | base64 --decode | ./lrjq run --file \"$pipeline_project_filter_path\""
                             )

        local return_code=0
        local install_steps_number=${#install_steps[@]}
    
        # Clean any previous logs
        date --rfc-3339=seconds > "$install_tmp_log"
        output_result+="###############################"$'\n'"### Steps: $install_steps_number ### Kicking off... ###"$'\n'"============="$'\n'
        output_result+=$(cat "$install_tmp_log")
        output_result+=$'\n'"============="$'\n'$'\n'

        # Now call the Steps
        for (( install_step_id=1; install_step_id<=$install_steps_number; install_step_id++ ))
         do
          if [ $return_code -eq 0 ]; then
            date --rfc-3339=seconds > "$install_tmp_log"
            eval "${install_steps[$install_step_id-1]} >>\"$install_tmp_log\" 2>>\"$install_tmp_log\"" || return_code=$?
            if [ $return_code -ne 0 ]; then
              output_error+="| (Step: $install_step_id / $install_steps_number) | \"${install_steps[$install_step_id-1]}\" : \"Failed.\" : Return code: \"$return_code\". |"
            fi
            output_result+="###############################"$'\n'"## Step: $install_step_id / $install_steps_number"$'\n'"\"${install_steps[$install_step_id-1]}\""$'\n'"============="$'\n'
            output_result+=$(cat "$install_tmp_log")
            output_result+=$'\n'"============="$'\n'$'\n'
           fi
         done      
      else # if [ -d "$pipeline_project_path" ]; then
        # it does.
        output_error="Pipeline Project doesn't exist."
      fi # if [ -d "$pipeline_project_path" ]; then
    fi # if [ "$log_to_test" == "" ] ; then
  else
      output_error="Parameter mis-formatted."
  fi

  # Prepping the output
  output_result=$(echo -n "$output_result" | base64 --wrap=0)
  output_error=$(echo -n "$output_error" | base64 --wrap=0)
  echo -e "{\"Result\": \"$output_result\", \"Error\": \"$output_error\"}"

  if [ "$output_error" == "" ] ; then
    exit 0
  fi
  exit 1
}

#######################################
# TestPipelineProjectTransform
#
# Goal: Test Pipeline Project Transform.
# Input: {"ProjectName": "%s", "LogToTest": "%s_base64_encoded"}
# Output: {"Result": "%s_base64_encoded", "Error": "%s_base64_encoded"}
#######################################
function TestPipelineProjectTransform() {
  local output_result=""
  local output_error=""
  local pipeline_project_path=""

  # Check the parameters
  local regex='"ProjectName"\s*:\s*"([^"]*)"\s*,\s*"LogToTest"\s*:\s*"([^"]*)"'
  if [[ "$1" =~ $regex ]]
    then
    local pipeline_project="${BASH_REMATCH[1]}"
    local log_to_test_raw="${BASH_REMATCH[2]}"
    local log_to_test=""

    log_to_test=$(echo "$log_to_test_raw" | base64 --decode 2>/dev/null) || log_to_test=""
    if [ "$log_to_test" == "" ] ; then
      output_error="Log must be provided, non-empty and encoded correctly (based64)."
    else # if [ "$log_to_test" == "" ] ; then

      pipeline_project_path="$PIPELINE_PROJECT_ROOT/$pipeline_project"
      # Check if pipeline project exists
      if [ -d "$pipeline_project_path" ]; then
        local pipeline_project_transform_path="$pipeline_project_path/transform.jq"

        # Prep the log files
        local log_files_root="$PROJECT_ROOT/OCHelper_logs"
        local install_tmp_log="$log_files_root/install_tmp.log"

        # Create Logs directory
        if [ ! -d "$log_files_root" ]; then
          mkdir "$log_files_root" 2>/dev/null
        fi

        # Define our installation steps
        local install_steps=( 
                              "echo -n \"LRJQ_Parsing_Result: \" >>\"$install_tmp_log\" && echo \"$log_to_test_raw\" | base64 --decode | ./lrjq run --file \"$pipeline_project_transform_path\""
                             )

        local return_code=0
        local install_steps_number=${#install_steps[@]}
    
        # Clean any previous logs
        date --rfc-3339=seconds > "$install_tmp_log"
        output_result+="###############################"$'\n'"### Steps: $install_steps_number ### Kicking off... ###"$'\n'"============="$'\n'
        output_result+=$(cat "$install_tmp_log")
        output_result+=$'\n'"============="$'\n'$'\n'

        # Now call the Steps
        for (( install_step_id=1; install_step_id<=$install_steps_number; install_step_id++ ))
         do
          if [ $return_code -eq 0 ]; then
            date --rfc-3339=seconds > "$install_tmp_log"
            eval "${install_steps[$install_step_id-1]} >>\"$install_tmp_log\" 2>>\"$install_tmp_log\"" || return_code=$?
            if [ $return_code -ne 0 ]; then
              output_error+="| (Step: $install_step_id / $install_steps_number) | \"${install_steps[$install_step_id-1]}\" : \"Failed.\" : Return code: \"$return_code\". |"
            fi
            output_result+="###############################"$'\n'"## Step: $install_step_id / $install_steps_number"$'\n'"\"${install_steps[$install_step_id-1]}\""$'\n'"============="$'\n'
            output_result+=$(cat "$install_tmp_log")
            output_result+=$'\n'"============="$'\n'$'\n'
           fi
         done      
      else # if [ -d "$pipeline_project_path" ]; then
        # it does.
        output_error="Pipeline Project doesn't exist."
      fi # if [ -d "$pipeline_project_path" ]; then
    fi # if [ "$log_to_test" == "" ] ; then
  else
      output_error="Parameter mis-formatted."
  fi

  # Prepping the output
  output_result=$(echo -n "$output_result" | base64 --wrap=0)
  output_error=$(echo -n "$output_error" | base64 --wrap=0)
  echo -e "{\"Result\": \"$output_result\", \"Error\": \"$output_error\"}"

  if [ "$output_error" == "" ] ; then
    exit 0
  fi
  exit 1
}

#######################################
# DeletePipelineProject
#
# Goal: Delete Pipeline project.
# Input: {"ProjectName": "%s"}
# Output: {"Result": "%s_base64_encoded", "Error": "%s_base64_encoded"}
#######################################
function DeletePipelineProject() {
  local output_result=""
  local output_error=""
  local pipeline_project_path=""

  # Check the parameters
  local regex='"ProjectName"\s*:\s*"([^"]*)"'
  if [[ "$1" =~ $regex ]]
    then
      local pipeline_project="${BASH_REMATCH[1]}"
      pipeline_project_path="$PIPELINE_PROJECT_ROOT/$pipeline_project"

      # Check if pipeline project exists
      if [ ! -d "$pipeline_project_path" ]; then
        # it does.
        output_error="Pipeline Project doesn't exist."
      else
        # it does. Let's go ahead.
        
        # Define our installation steps
        local install_steps=( 
                             "[[ -f \"$PIPELINE_PROJECT_ROOT/$pipeline_project.pipe\" ]] && rm --force \"$PIPELINE_PROJECT_ROOT/$pipeline_project.pipe\" && echo \"Deleting existing Pipeline ($pipeline_project.pipe).\"|| echo \"No Pipeline ($pipeline_project.pipe) file found. All good. Carrying on.\""
                             "[[ -d \"$pipeline_project_path\" ]] && rm --recursive --force \"$pipeline_project_path\" && echo \"Deleting Pipeline directory.\"|| echo \"No Pipeline directory to delete.\""
                             "ls -l \"$PIPELINE_PROJECT_ROOT\""
                             )

        # Prep the log files
        local log_files_root="$PROJECT_ROOT/OCHelper_logs"
        local install_tmp_log="$log_files_root/install_tmp.log"

        # Create Logs directory
        if [ ! -d "$log_files_root" ]; then
          mkdir "$log_files_root" 2>/dev/null
        fi

        local return_code=0
        local install_steps_number=${#install_steps[@]}
    
        # Clean any previous logs
        date --rfc-3339=seconds > "$install_tmp_log"
        output_result+="###############################"$'\n'"### Steps: $install_steps_number ### Kicking off... ###"$'\n'"============="$'\n'
        output_result+=$(cat "$install_tmp_log")
        output_result+=$'\n'"============="$'\n'$'\n'

        # Now call the Steps
        for (( install_step_id=1; install_step_id<=$install_steps_number; install_step_id++ ))
         do
          if [ $return_code -eq 0 ]; then
            date --rfc-3339=seconds > "$install_tmp_log"
            eval "${install_steps[$install_step_id-1]} >>\"$install_tmp_log\" 2>>\"$install_tmp_log\"" || return_code=$?
            if [ $return_code -ne 0 ]; then
           output_error+="| (Step: $install_step_id / $install_steps_number) | \"${install_steps[$install_step_id-1]}\" : \"Failed.\" : Return code: \"$return_code\". |"
            fi
            output_result+="###############################"$'\n'"## Step: $install_step_id / $install_steps_number"$'\n'"\"${install_steps[$install_step_id-1]}\""$'\n'"============="$'\n'
            output_result+=$(cat "$install_tmp_log")
            output_result+=$'\n'"============="$'\n'$'\n'
           fi
         done      
      fi
    else
      output_error="Parameter mis-formatted."
  fi

  # Prepping the output
  output_result=$(echo -n "$output_result" | base64 --wrap=0)
  output_error=$(echo -n "$output_error" | base64 --wrap=0)
  echo -e "{\"Result\": \"$output_result\", \"Error\": \"$output_error\"}"

  if [ "$output_error" == "" ] ; then
    exit 0
  fi
  exit 1
}

#######################################
# CheckInternetConnectivity
#
# Goal: Check for Internet Connectivity.
# Input: 
# Output: {"Result": "%s", "Detailed": [{"Domain": "%s", "Reachable": "%bool"}], "Error": "%s_base64_encoded"}
#######################################

# Small internal function to check a URL
function check_url() {
  command -p curl -Lsf --connect-timeout 5 "$1" >/dev/null 2>/dev/null
}

# The meaty function
function CheckInternetConnectivity() {
  local output_result=""
  local output_error=""
  local domains_table="["
  
  local domains_checked=0
  local domains_checked=0
  local domain_reached=""
  for domain_to_check in "${REQUIRED_DOMAINS[@]}"; do
    domains_checked=$(($domains_checked + 1))
    domain_reached="false"
    if check_url "https://$domain_to_check" ; then
      domains_reached=$(($domains_reached + 1))
      domain_reached="true"
    fi
    # Add the domain to the table
    domains_table+="{\"Domain\": \"$domain_to_check\", \"Reachable\": \"$domain_reached\"}"
  done

  # Add the Commas to separate the entries
  domains_table=${domains_table//$BACK_TO_BACK_BRACKETS/$BACK_TO_BACK_BRACKETS_WITH_COMMA}
  domains_table+="]"

  # Prepping the output
  if [ $domains_reached -eq $domains_checked ] ; then
    output_result="Full Internet Connectivity ($domains_reached / $domains_checked)"
  fi
  if [ $domains_reached -lt $domains_checked ] ; then
    output_result="Partial Internet Connectivity ($domains_reached / $domains_checked)"
  fi
  if [ $domains_reached -eq 0 ] ; then
    output_result="No Internet Connectivity ($domains_reached / $domains_checked)"
  fi
  
  output_error=$(echo -n "$output_error" | base64 --wrap=0)
  echo -e "{\"Result\": \"$output_result\", \"Detailed\": $domains_table, \"Error\": \"$output_error\"}"

  if [ "$output_error" == "" ] ; then
    exit 0
  fi
  exit 1
}

#######################################
# SelfIntegrityCheck
#
# Goal: Self integrity check.
# Input: 
# Output: {"Integrity": "%s"}
#######################################
function SelfIntegrityCheck() {
  local return_code=0
  local script_signature="" # Signature saved in the file
  local calculated_signature="" # Signature calculated from the script file
  local output_result="Failed to test"

  # Get the signature from the bottom of the script
  script_signature=$(tail -1 $SCRIPT_NAME | grep --only-matching --perl-regexp '(?<=md5:)[a-z0-9]*(?=:5dm)' 2>/dev/null) || return_code=$?
  if [ $return_code -eq 0 ]; then
    # All good, let's carry on
    # Now calculate the signature from the file itself (minus the last line)
    calculated_signature=$(head --lines=-1 $SCRIPT_NAME | md5sum | grep --only-matching '^[a-z0-9]*' 2>/dev/null) || return_code=$?
    if [ $return_code -eq 0 ]; then
      # All good, let's carry on
      if [ "$calculated_signature" == "$script_signature" ] ; then
        output_result="Good"
      else
        output_result="Bad"
      fi
    fi
  fi
  
  echo -e "{\"Integrity\": \"$output_result\"}"

  if [ $return_code -eq 0 ] ; then
    exit 0
  fi
  exit 1
}

#######################################
# ReadOCLogs
#
# Goal: Extract OC Logs.
# Input: 
# Output: %RawLogs%
#######################################
function ReadOCLogs() {
  # First establish if "lrctl" is present and running
  local lrctl_present=1
  ./lrctl --help >/dev/null 2>/dev/null || lrctl_present=-1

  if [ $lrctl_present -eq 1 ]; then
    # "lrctl"is present.
    ./lrctl open-collector logs 2>/dev/null
    exit 0
  else
    # No "lrctl", we stop here.
    exit 1
  fi
  
  exit 1
}

#######################################
# EnableInstalledPipeline
#
# Goal: Enable Installed Pipeline.
# Input: {"PipelineName": "%s"}
# Output: {"Result": "%s_base64_encoded", "Error": "%s_base64_encoded"}
#######################################
function EnableInstalledPipeline() {
  # lrctl open-collector -- pipe enable <pipename>
  # lrctl open-collector -- pipe enable pubsubbeat/pubsubbeat

  local output_result=""
  local output_error=""

  # Check the parameters
  local regex='"PipelineName"\s*:\s*"([^"]*)"'
  if [[ "$1" =~ $regex ]]
    then
      local pipeline_name="${BASH_REMATCH[1]}"

      # Define our installation steps
      local install_steps=( 
                           "./lrctl help"
                           "./lrctl open-collector -- pipe enable \"$pipeline_name\"" # XXXXX - Gave up debugging. Disabled if from the UI for now. This one gets stuck when run from the OC UI over SSH. But works a treat if run from the command line.
                           )

      # Prep the log files
      local log_files_root="$PROJECT_ROOT/OCHelper_logs"
      local install_tmp_log="$log_files_root/install_tmp.log"

      # Create Logs directory
      if [ ! -d "$log_files_root" ]; then
        mkdir "$log_files_root" 2>/dev/null
      fi

      local return_code=0
      local install_steps_number=${#install_steps[@]}
  
      # Clean any previous logs
      date --rfc-3339=seconds > "$install_tmp_log"
      output_result+="###############################"$'\n'"### Steps: $install_steps_number ### Kicking off... ###"$'\n'"============="$'\n'
      output_result+=$(cat "$install_tmp_log")
      output_result+=$'\n'"============="$'\n'$'\n'

      # Now call the Steps
      for (( install_step_id=1; install_step_id<=$install_steps_number; install_step_id++ ))
       do
        if [ $return_code -eq 0 ]; then
          date --rfc-3339=seconds > "$install_tmp_log"
          eval "${install_steps[$install_step_id-1]} >>\"$install_tmp_log\" 2>>\"$install_tmp_log\"" || return_code=$?
          if [ $return_code -ne 0 ]; then
            output_error+="| (Step: $install_step_id / $install_steps_number) | \"${install_steps[$install_step_id-1]}\" : \"Failed.\" : Return code: \"$return_code\". |"
          fi
          output_result+="###############################"$'\n'"## Step: $install_step_id / $install_steps_number"$'\n'"\"${install_steps[$install_step_id-1]}\""$'\n'"============="$'\n'
          output_result+=$(cat "$install_tmp_log")
          output_result+=$'\n'"============="$'\n'$'\n'
         fi
       done      
    else
      output_error="Parameter mis-formatted."
  fi

  # Prepping the output
  #output_result=$(echo -n "$output_result" | base64 --wrap=0)
  #output_error=$(echo -n "$output_error" | base64 --wrap=0)
  echo -e "{\"Result\": \"$output_result\", \"Error\": \"$output_error\"}"

  if [ "$output_error" == "" ] ; then
    exit 0
  fi
  exit 1
}

#######################################
# DisableInstalledPipeline
#
# Goal: Disable Installed Pipeline.
# Input: {"PipelineName": "%s"}
# Output: {"Result": "%s_base64_encoded", "Error": "%s_base64_encoded"}
#######################################
function DisableInstalledPipeline() {
  #./lrctl open-collector -- pipe disable <pipename>
  #./lrctl open-collector -- pipe disable pubsubbeat/pubsubbeat
  
  local output_result=""
  local output_error=""

  # Check the parameters
  local regex='"PipelineName"\s*:\s*"([^"]*)"'
  if [[ "$1" =~ $regex ]]
    then
      local pipeline_name="${BASH_REMATCH[1]}"

      # XXXXXX Debug
      pipeline_name="pubsubbeat/pubsubbeat"

      # Define our installation steps
      local install_steps=( 
                           "./lrctl open-collector -- pipe disable \"$pipeline_name\""
                           )

      # Prep the log files
      local log_files_root="$PROJECT_ROOT/OCHelper_logs"
      local install_tmp_log="$log_files_root/install_tmp.log"

      # Create Logs directory
      if [ ! -d "$log_files_root" ]; then
        mkdir "$log_files_root" 2>/dev/null
      fi

      local return_code=0
      local install_steps_number=${#install_steps[@]}
  
      # Clean any previous logs
      date --rfc-3339=seconds > "$install_tmp_log"
      output_result+="###############################"$'\n'"### Steps: $install_steps_number ### Kicking off... ###"$'\n'"============="$'\n'
      output_result+=$(cat "$install_tmp_log")
      output_result+=$'\n'"============="$'\n'$'\n'

      # Now call the Steps
      for (( install_step_id=1; install_step_id<=$install_steps_number; install_step_id++ ))
       do
        if [ $return_code -eq 0 ]; then
          date --rfc-3339=seconds > "$install_tmp_log"
          eval "${install_steps[$install_step_id-1]} >>\"$install_tmp_log\" 2>>\"$install_tmp_log\"" || return_code=$?
          if [ $return_code -ne 0 ]; then
         output_error+="| (Step: $install_step_id / $install_steps_number) | \"${install_steps[$install_step_id-1]}\" : \"Failed.\" : Return code: \"$return_code\". |"
          fi
          output_result+="###############################"$'\n'"## Step: $install_step_id / $install_steps_number"$'\n'"\"${install_steps[$install_step_id-1]}\""$'\n'"============="$'\n'
          output_result+=$(cat "$install_tmp_log")
          output_result+=$'\n'"============="$'\n'$'\n'
         fi
       done      
    else
      output_error="Parameter mis-formatted."
  fi

  # Prepping the output
  #output_result=$(echo -n "$output_result" | base64 --wrap=0)
  #output_error=$(echo -n "$output_error" | base64 --wrap=0)
  echo -e "{\"Result\": \"$output_result\", \"Error\": \"$output_error\"}"

  if [ "$output_error" == "" ] ; then
    exit 0
  fi
  exit 1
}

#######################################
#
# MAIN
#
#######################################
function main() {
  # Required tools
  required $REQUIRED_TOOLS

  # Parse options
  while [[ $# -ge $OPTIND ]] && eval opt=\${$OPTIND} || break
        [[ $opt == -- ]] && shift && break
        if [[ $opt == --?* ]]; then
          opt=${opt#--}; shift

          # Argument to option ?
          OPTARG=;local has_arg=0
          [[ $opt == *=* ]] && OPTARG=${opt#*=} && opt=${opt%=$OPTARG} && has_arg=1

          # Check if known option and if it has an argument if it must:
          local state=0
          for option in "${LONG_OPTS[@]}"; do
            [[ "$option" == "$opt" ]] && state=1 && break
            [[ "${option%:}" == "$opt" ]] && state=2 && break
          done
          # Param not found
          [[ $state = 0 ]] && OPTARG=$opt && opt='?'
          # Param with no args, has args
          [[ $state = 1 && $has_arg = 1 ]] && OPTARG=$opt && opt=::
          # Param with args, has no args
          if [[ $state = 2 && $has_arg = 0 ]]; then
            [[ $# -ge $OPTIND ]] && eval OPTARG=\${$OPTIND} && shift || { OPTARG=$opt; opt=:; }
          fi

          # for the while
          true
        else
          getopts ":$SHORT_OPTS" opt
        fi
  do
  case "$opt" in
      # List of options
      v|version)    version_command; exit 0; ;;
      h|help)       help_command ;;
      force)        FORCE=true ;;
      # Generated by "20190731.Open Collector UI - OCHelper - Specs.xlsx", Tab 'case "$opt" in'
      CheckOCHelperVersion)               CheckOCHelperVersion ;;
      CheckOSVersion)                     CheckOSVersion ;;
      CheckDockerPresence)                CheckDockerPresence ;;
      CheckDockerVersion)                 CheckDockerVersion ;;
      CheckOCPresence)                    CheckOCPresence ;;
      CheckOCVersion)                     CheckOCVersion ;;
      CheckOCHealth)                      CheckOCHealth ;;
      ReadOCConfiguration)                ReadOCConfiguration ;;
      ListInstalledPipelines)             ListInstalledPipelines ;;
      ListPipelineProjects)               ListPipelineProjects ;;
      GetPipelineProjectFilter)           GetPipelineProjectFilter "$OPTARG" ;;
      GetPipelineProjectTransform)        GetPipelineProjectTransform "$OPTARG" ;;
      InstallDocker)                      InstallDocker "$OPTARG" ;;
      UpgradeDocker)                      UpgradeDocker "$OPTARG" ;;
      DeployLatestLrctl)                  DeployLatestLrctl "$OPTARG" ;;
      DeployLatestLRJQ)                   DeployLatestLRJQ "$OPTARG" ;;
      DeployLatestOcpipeline)             DeployLatestOcpipeline "$OPTARG" ;;
      InstallOC)                          InstallOC "$OPTARG" ;;
      UpgradeOC)                          UpgradeOC "$OPTARG" ;;
      RestartOC)                          RestartOC "$OPTARG" ;;
      StartOC)                            StartOC "$OPTARG" ;;
      StopOC)                             StopOC "$OPTARG" ;;
      WriteOCConfiguration)               WriteOCConfiguration "$OPTARG" ;;
      CreatePipelineProject)              CreatePipelineProject "$OPTARG" ;;
      UpdatePipelineProjectFilter)        UpdatePipelineProjectFilter "$OPTARG" ;;
      UpdatePipelineProjectTransform)     UpdatePipelineProjectTransform "$OPTARG" ;;
      PackagePipelineProject)             PackagePipelineProject "$OPTARG" ;;
      InstallPipelinePackage)             InstallPipelinePackage "$OPTARG" ;;
      TestPipelineProjectFilter)          TestPipelineProjectFilter "$OPTARG" ;;
      TestPipelineProjectTransform)       TestPipelineProjectTransform "$OPTARG" ;;
      DeletePipelineProject)              DeletePipelineProject "$OPTARG" ;;
      CheckInternetConnectivity)          CheckInternetConnectivity ;;
      SelfIntegrityCheck)                 SelfIntegrityCheck ;;
      ReadOCLogs)                         ReadOCLogs ;;
      EnableInstalledPipeline)            EnableInstalledPipeline "$OPTARG" ;;
      DisableInstalledPipeline)           DisableInstalledPipeline "$OPTARG" ;;
      # Errors
      ::)  err "Unexpected argument to option '$OPTARG'"; exit 2; ;;
      :)  err "Missing argument to option '$OPTARG'"; exit 2; ;;
      \?)  err "Unknown option '$OPTARG'"; exit 2; ;;
      *)  err "Internal script error, unmatched option '$opt'"; exit 2; ;;
    esac
  done
  readonly FORCE
  shift $((OPTIND-1))

  # No more arguments -> call default command
  [[ -z "$1" ]] && default_command

  # Set command and arguments
  command="$1" && shift
  args="$@"

  # Execute the command
  case "$command" in
    # help
    help)     help_command ;;

    # version
    version)  version_command ;;

    # Unknown command
    *)  err "Unknown command '$command'"; exit 2; ;;
  esac
}
#######################################
# Run the script
#######################################
main "$@"

#### DO NOT MODIFY THIS LINE - MD5SIGNATURE - 4c6f6752687974686d2d4f4348656c706572 - md5:acd756fb58cc08e902a990805ca2c3dd:5dm